// PRQA S 1050 EOF
/*

	Copyright 1995-2021, Advanced Computer Systems , Inc.
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.acsys.it

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Advanced Computer Systems;
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Advanced Computer Systems, Inc.

	$Prod: A.C.S. Db Cryosat Library $

	$Id$

	$Author$

	$Log$
	Revision 5.7  2016/04/28 09:20:02  marpas
	simplified using convenience macros from dbPersistent.h
	
	Revision 5.6  2016/04/19 13:12:13  marpas
	removing filedName method
	
	Revision 5.5  2016/04/11 13:27:13  marpas
	adopting new db interfaces
	
	Revision 5.4  2016/03/26 21:42:59  marpas
	using new db I/F
	
	Revision 5.3  2013/07/22 18:01:03  marpas
	aligning to new libDbData interface
	
	Revision 5.2  2013/07/18 11:11:53  marpas
	different exception raised in case the space was not loaded or not found in the db.
	
	Revision 5.1  2013/06/11 14:27:21  marpas
	coding best practices applied
	
	Revision 5.0  2013/06/11 14:16:32  marpas
	adopting libException 5.x standards
	
	Revision 2.15  2013/06/07 13:43:45  marpas
	using pool if no connection
	
	Revision 2.14  2013/04/12 12:13:31  marpas
	SQLDialectFactory::dialectName() needs a db connection key
	
	Revision 2.13  2013/03/29 19:51:19  marpas
	removing html related functions
	
	Revision 2.12  2013/03/14 15:27:23  marpas
	connection pool concept use enforced
	interface rationalization
	
	Revision 2.11  2013/02/25 10:08:03  marpas
	using StringUtils::findNoCase
	
	Revision 2.10  2013/01/24 19:22:39  marpas
	connection pool management improved
	
	Revision 2.9  2013/01/23 17:23:09  marpas
	introducing dbConnectionPool for factories
	coding best practices
	interface rationalization
	qa rules
	
	Revision 2.8  2012/06/15 09:59:53  marpas
	fixing inherited methods
	
	Revision 2.7  2012/02/13 16:53:02  marpas
	refactoring
	
	Revision 2.6  2011/03/02 18:23:44  marpas
	serial 8 support
	
	Revision 2.5  2010/03/08 11:17:41  enrcar
	EC:: Oracle compatibility added
	
	Revision 2.4  2009/03/30 17:48:54  marpas
	robust implementation
	rules ...
	
	Revision 2.3  2009/02/17 10:35:10  marpas
	dbParam obsolete ctors removed
	
	Revision 2.2  2008/10/08 12:48:57  crivig
	porting to postgres8
	
	Revision 2.1  2006/06/09 11:52:34  giucas
	Update method fixed
	
	Revision 2.0  2006/02/28 09:09:03  marpas
	Exception 2.1 I/F adopted
	
	Revision 1.2  2005/11/24 10:56:01  enrcar
	Updated to SQLString. Now clob upload/download performed by dialect
	
	Revision 1.1  2005/07/21 10:24:43  marpas
	dbConfigurationSpace and its query imported from libDbCryosat
	
	Revision 1.39  2005/06/15 07:44:49  integrator
	multiple storage manager implemented
	
	Revision 1.38  2005/03/09 18:03:23  marpas
	some messages fixed
	namespaces fixed
	
	Revision 1.37  2005/03/04 22:49:07  marpas
	dbWaitingOrder and dbWaitingOrderQuery classes  and their tests added , db_values script updated accordingly
	
	Revision 1.36  2004/10/04 15:13:52  ivafam
	When set orderBy control if orderBySQLDString contain already clause "ORDER BY"
	
	Revision 1.35  2004/07/13 15:15:44  paoscu
	using namespace std no longer in includes
	exDbPersistent is an abstract class
	
	Revision 1.34  2004/07/07 10:34:32  paoscu
	dbPersistent I/F chnaged
	
	Revision 1.33  2004/05/03 14:55:33  paoscu
	Paramer "id" removed in method "remove"
	
	Revision 1.32  2004/04/16 12:49:34  paoscu
	Bug fixed in Lock usage
	
	Revision 1.31  2004/04/13 16:57:08  paoscu
	ThreadSafe::Lock used.
	clobe() method added.
	
	Revision 1.30  2004/03/04 18:54:08  paoscu
	Class generated again. New clob management.
		

*/

// This file is automatically generated by dbGenerator tool

#include <dbConfigurationSpace.h>
#include <dbQuery.h>
#include <dbRow.h>
#include <dbSet.h>
#include <dbConv.h>
#include <dbConnectionPool.h>
#include <Transaction.h>
#include <ResourceSpace.h>
#include <rsResourceSet.h>
#include <rsPushNSpace.h>
#include <File.h>
#include <unistd.h>
#include <sstream>
#include <XMLOstream.h>

#include <SQLString.h>


_ACS_BEGIN_NAMESPACE(acs)

using namespace std ;



ACS_CLASS_DEFINE_DEBUG_LEVEL(dbConfigurationSpace)

// constructor
dbConfigurationSpace::dbConfigurationSpace() :
	dbPersistent(),
	_namespace() ,
	_namespaceSet() ,
	_version() ,
	_versionSet() ,
	_spaceUploadFileName() ,
	_spaceUploadFileNameSet()
{
}


// copy constructor
dbConfigurationSpace::dbConfigurationSpace(const dbConfigurationSpace &o):
	dbPersistent(o),
	_namespace(o._namespace) ,
	_namespaceSet(o._namespaceSet) ,
	_version(o._version) ,
	_versionSet(o._versionSet) ,
	_spaceUploadFileName(o._spaceUploadFileName) ,
	_spaceUploadFileNameSet(o._spaceUploadFileNameSet)
{
}


dbConfigurationSpace::~dbConfigurationSpace() throw() {}



dbPersistent *dbConfigurationSpace::clone() const
{
	return new dbConfigurationSpace(*this) ;
}


// operator =
dbConfigurationSpace &dbConfigurationSpace::operator=(const dbConfigurationSpace &o)
{
	Lock lock(*this) ; // PRQA S 3050 2
    Lock lo(o) ;
	if(this != &o)
	{
		// base classe assignement
		dbPersistent::operator=(o) ;
		// assignement of private data
		_namespace=o._namespace;
		_namespaceSet=o._namespaceSet;
		_version=o._version;
		_versionSet=o._versionSet;
		_spaceUploadFileName=o._spaceUploadFileName;
		_spaceUploadFileNameSet=o._spaceUploadFileNameSet;
	}
	return *this ;
}


string dbConfigurationSpace::className() const
{
	return staticClassName() ;
}


string dbConfigurationSpace::staticClassName()
{
	return "dbConfigurationSpace" ;
}


// initialize the class
void dbConfigurationSpace::reset()
{
	Lock lock(*this) ; // PRQA S 3050

	// reset dbPersistent
	dbPersistent::reset() ;
	_namespace="" ;
	_namespaceSet=false ;
	_version="" ;
	_versionSet=false ;
	_spaceUploadFileName="" ;
	_spaceUploadFileNameSet=false ;
}


// save the data in database
dbPersistent::IdType dbConfigurationSpace::save(dbConnection &conn) // PRQA S 4020
{
	Lock lock(*this) ; // PRQA S 3050

	// no modification since epoch ... no save
	if (not isModified()) { return 0 ; }

	
    // PRQA S 3081 5
	ACS_COND_THROW(isFromDatabase(),InvalidUse("Error: dbConfigurationSpace::save(). Use the method update() instead of save().")) ;
	ACS_COND_THROW(!_namespaceSet,InvalidUse("Mandatory field \"Namespace\" must be set.")) ;
	ACS_COND_THROW(!_versionSet,InvalidUse("Mandatory field \"Version\" must be set.")) ;
	ACS_COND_THROW(!_spaceUploadFileNameSet,InvalidUse("Mandatory field \"Space\" must be set.")) ;

	// inside a transaction
	db::Transaction transaction(conn) ;

	// start of it
	transaction.begin_work("dbConfigurationSpace_SAVE") ;
	conn.addStateWrapper(*this) ;

	// prepare the Query
	dbQuery query(conn) ;

	string uploadfile = _spaceUploadFileName ;



    const string &dbKey = conn.getKey() ;

    // Creating blank namespace

    SQLString tmp(dbKey, SQLString::INSERT ) ;

    // Add Table list
    tmp.addTableList( getTable() );

    // Add Values
    {
        tmp.addValuesList( "Namespace", dbConv(dbKey, _namespace) ) ; // PRQA S 3050, 3081 2
        tmp.addValuesList( "Version", dbConv(dbKey, _version) ) ;
        // Space unset
    }
   
    query.sqlString( tmp, "ConfigurationSpaceSave" );

	// save the record
	query.execForStatus();


    // upload space:
    replaceSpaceFile(uploadfile, conn) ; 

	transaction.commit() ;

	// record that the values come from the database
	setFromDatabase() ; 
	return 0 ;
}


// load the class from the database. Return true if object exist
bool dbConfigurationSpace::load(dbConnection &conn , IdType id) // PRQA S 4020
{
	Lock lock(*this) ; // PRQA S 3050

	dbConfigurationSpace tempRecord(*this); //store current record.

	// reset current record
	reset() ; 

	ACS_CLASS_ANNOUNCE_DEBUG(ACS_VLO_VERB) ;

    const string & dbKey = conn.getKey() ;

    SQLString sqlString (dbKey, SQLString::SELECT) ;
	sqlString.addSelectList (getFields());
	sqlString.addTableList (getTable());


	// Manage Space Name
	if (tempRecord._namespaceSet)
	{
		// Set the namespace if provided
		dbQueryParameters pp(dbKey) ;
		pp.addParameter(dbParam(dbKey, getTable(), "Namespace", dbParam::EQUAL_TO , db::toSQL(dbKey, tempRecord._namespace) ) );
		sqlString.addANDWhereParameter(pp) ;
	}
	else
	{
		// Otherwhise check the NULL namespace
		dbQueryParameters pp(dbKey) ;
		pp.addParameter(dbParam(dbKey, getTable(), "Namespace", dbParam::ISNULL) );
		sqlString.addANDWhereParameter(pp) ;
	}

	// query for a specific version if provided
	if (tempRecord._versionSet  && !tempRecord._version.empty() ) 
	{
		dbQueryParameters pp(dbKey) ;
		pp.addParameter(dbParam(dbKey, getTable(), "Version", dbParam::EQUAL_TO , db::toSQL(dbKey, tempRecord._version) ) );
		sqlString.addANDWhereParameter(pp) ;
	}

	// else load records with all available versions and use sort to select the wanted one
	// note that we need a specific order by to sort 

	sqlString.addOrderByList("Namespace", SQLString::SORT_DEFAULT) ;

	const string dialectName = SQLDialectFactory::dialectName(dbKey);
	if (dialectName == "Postgres8") 
	{
		sqlString.addOrderByList("TO_NUMBER(SUBSTRING(Version FROM 0 FOR POSITION('.' IN Version)), '99')", SQLString::DESC) ;
		sqlString.addOrderByList("TO_NUMBER(SUBSTRING(Version FROM POSITION('.' IN Version) + 1 FOR LENGTH(Version)), '99')", SQLString::DESC) ;
	}
	else
	{
		sqlString.addOrderByList("Version", SQLString::DESC) ;
	}

	// Interested in just one item
	sqlString.setLimit (1);

	dbQuery query(conn, sqlString, "ConfigurationSpaceLoad") ;
	dbSet set ;
	dbRow row(dbKey) ;

	ACS_CLASS_WRITE_DEBUG(ACS_LOW_VERB, "SQL = \"" << sqlString.getSQL() << "\"") ;

	// we want to load just the first row (see the order by aboce)
	query.execForSet(set) ;

	// explicit check on empty set
	if (0 == set.size() )
	{
		*this = tempRecord;  //Nothing found: restore previuos situation.
		return false ;
	}

	// get the row
	set.getNextRow(row);

	// found it .. load into memory
	loadRow(row, 0) ;

	// now the object is from DB
	setFromDatabase() ;

	// and no longer modified ... in case it were 
	resetModifiedFlag() ;

	ACS_CLASS_WRITE_DEBUG(ACS_LOW_VERB, "Dump : \"" << *this << "\"") ;
	// loaded --- hence true
	return true;

}


// update an existing instance in database
dbPersistent::IdType dbConfigurationSpace::update(dbConnection &conn)
{
	ACS_THROW(InvalidUse("No update foreseen on this record type")) ;  // PRQA S 3081
}


// remove the class from the database
dbPersistent::IdType dbConfigurationSpace::remove(dbConnection &conn)
{
	Lock lock(*this) ; // PRQA S 3050

    const string & dbKey = conn.getKey() ;

    SQLString sqlString (dbKey, SQLString::DELETE) ;
	sqlString.addTableList (getTable());


	// Manage Space Name
	if (_namespaceSet)
	{
		// Set the namespace if provided
		dbQueryParameters pp(dbKey) ;
		pp.addParameter(dbParam(dbKey, getTable(), "Namespace", dbParam::EQUAL_TO , db::toSQL(dbKey, _namespace) ) );
		sqlString.addANDWhereParameter(pp) ;
	}
	else
	{
		// Otherwhise check the NULL namespace
		dbQueryParameters pp(dbKey) ;
		pp.addParameter(dbParam(dbKey, getTable(), "Namespace", dbParam::ISNULL) );
		sqlString.addANDWhereParameter(pp) ;
	}

	// query for a specific version if provided
	if (_versionSet) 
	{
		dbQueryParameters pp(dbKey) ;
		pp.addParameter(dbParam(dbKey, getTable(), "Version", dbParam::EQUAL_TO , db::toSQL(dbKey, _version) ) );
		sqlString.addANDWhereParameter(pp) ;
    }
	else
	{
		// Otherwhise check the NULL namespace
		dbQueryParameters pp(dbKey) ;
		pp.addParameter(dbParam(dbKey, getTable(), "Version", dbParam::ISNULL) );
		sqlString.addANDWhereParameter(pp) ;
	}

	// inside a transaction
	db::Transaction transaction(conn) ;

	// start of it
	transaction.begin_work("dbConfigurationSpace_REMOVE") ;

	conn.addStateWrapper(*this) ;
	dbQuery query(conn, sqlString, "ConfigurationSpaceRemove") ;
    // execute 
    query.execForStatus() ;
	// commit
	transaction.commit() ;

	// no more from DB (just removed)
	resetFromDatabase() ;
	
	// for sure it is modified .. dos not reflect any longer DB state
	setModifiedFlag() ;

	return 0 ;
}


// True if the class have valid parameters, false otherwise
bool dbConfigurationSpace::validate() const
{
	Lock lock(*this) ; // PRQA S 3050

	return true;
}


// export the class to stream
void dbConfigurationSpace::exportObj(rsResourceSet &s) const
{
	// thread safety
	Lock lock(*this) ; // PRQA S 3050

	rsPushNSpace nsp(s,"dbConfigurationSpace") ;
	// export base classes
	dbPersistent::exportObj(s) ;
    RSSetM(s, _namespaceSet, _namespace) ;
    RSSetM(s, _versionSet, _version) ;
}


// import the class from a stream
void dbConfigurationSpace::importObj(rsResourceSet &s)
{
	// thread safety
	Lock lock(*this) ; // PRQA S 3050

	rsPushNSpace nsp(s,"dbConfigurationSpace") ;
	// import base classes
	dbPersistent::importObj(s) ;
    RSGetM(s, _namespaceSet, _namespace) ;
    RSGetM(s, _versionSet, _version) ;
}


// export the class to XML stream
void dbConfigurationSpace::exportXML(XMLOstream &xst) const
{
	// thread safety
	Lock lock(*this) ; // PRQA S 3050

	XMLOstream::Tag txml(xst, "dbConfigurationSpace");
	// export base classes
	dbPersistent::exportXML(xst) ;
	
    XMLTagM(xst, _namespaceSet, _namespace, "Namespace") ;
    XMLTagM(xst, _versionSet, _version, "Version") ;
}



// load the object from a row
int dbConfigurationSpace::loadRow(const dbRow &row, int offset)
{
	// thread safety
	Lock lock(*this) ; // PRQA S 3050

	// at least 2 columns
	// 0 name
	// 1 version
	row.columnSet(offset + 0, _namespace, _namespaceSet) ; // PRQA S 3000, 3010 2
	row.columnSet(offset + 1, _version, _versionSet) ;

	// just loaded from DB
	setFromDatabase() ;

	return offset + 2 ; // PRQA S 4400
}



void dbConfigurationSpace::setNamespace(const string &v)
{
	Lock lock(*this) ; // PRQA S 3050

	ACS_COND_THROW(isFromDatabase(),InvalidUse("Error: dbConfigurationSpace::setNamespace(). Primary Key is from Database.")) ; // PRQA S 3081

	ACS_COND_THROW(v.size() > 64,InvalidUse("Error: dbConfigurationSpace::setNamespace(). String too long.")) ; // PRQA S 3081

	if (!_namespaceSet || (_namespace != v) ) 
	{
		// set the value
		_namespace = v ;
		// remember it was set
		_namespaceSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbConfigurationSpace::getNamespace(bool *set) const
{
	Lock lock(*this) ; // PRQA S 3050

	if (set) {
		*set = _namespaceSet ;
    }
	return _namespace ;
}


void dbConfigurationSpace::unsetNamespace()
{
	ACS_COND_THROW(isFromDatabase(),InvalidUse("Error: dbConfigurationSpace::unsetNamespace(). Primary Key is from Database.")) ; // PRQA S 3081

	Lock lock(*this) ; // PRQA S 3050
	// reset
	if(_namespaceSet) {
		setModifiedFlag();
    }
	_namespaceSet = false;

}
void dbConfigurationSpace::setVersion(const string &v)
{
	Lock lock(*this) ; // PRQA S 3050

	ACS_COND_THROW(isFromDatabase(),InvalidUse("Error: dbConfigurationSpace::setVersion(). Primary Key is from Database.")) ; // PRQA S 3081

	ACS_COND_THROW(v.size() > 8,InvalidUse("Error: dbConfigurationSpace::setVersion(). String too long.")) ; // PRQA S 3081

	if (!_versionSet || _version != v ) 
	{
		// set it
		_version = v ;
		// remember the flag
		_versionSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbConfigurationSpace::getVersion(bool *set) const
{
	Lock lock(*this) ; // PRQA S 3050

	if (set) {
		*set = _versionSet ;
    }
	return _version ;
}


void dbConfigurationSpace::unsetVersion()
{
	ACS_COND_THROW(isFromDatabase(),InvalidUse("Error: dbConfigurationSpace::unsetVersion(). Primary Key is from Database.")) ; // PRQA S 3081

	Lock lock(*this) ; // PRQA S 3050
	// reset
	if(_versionSet) {
		setModifiedFlag();
    }
	_versionSet = false;

}
void dbConfigurationSpace::replaceSpaceFile(const string &path, dbConnection &conn) // PRQA S 4211
{
	Lock lock(*this) ; // PRQA S 3050

	// check againt empty name or version
	ACS_COND_THROW(_namespace.empty(),ObjectNotLoaded("_namespace is an empty string.")) ; // PRQA S 3081
	ACS_COND_THROW(_version.empty(),ObjectNotLoaded("_version is an empty string.")) ; // PRQA S 3081
	string uploadfile = path ;

	// check against no path
	ACS_COND_THROW(uploadfile.empty(),ObjectNotLoaded("Path is empty.")) ; // PRQA S 3081
    
    const string & dbKey = conn.getKey() ;
    
	// is a CLOB upload
    SQLString queryString(dbKey, SQLString::LOBJ_UPLOAD ) ;
    queryString.setColumnAndFileName( "Space", uploadfile );
    queryString.addTableList( getTable() );
    {
        dbQueryParameters p(dbKey) ;
        if(_namespaceSet) {
            p.addParameter( dbParam(dbKey, "t_configurationspaces","namespace" , dbParam::EQUAL_TO, dbConv(dbKey, _namespace)) ) ;   // PRQA S 3050, 3081
        }
        else { // should not happen - see above exceptions
            p.addParameter( dbParam(dbKey, "t_configurationspaces","namespace" , dbParam::ISNULL) ) ;
        }
        queryString.addANDWhereParameter(p) ;
    }

    {
        dbQueryParameters p(dbKey) ;
        if(_versionSet) {
            p.addParameter( dbParam(dbKey, "t_configurationspaces","version" , dbParam::EQUAL_TO, dbConv(dbKey, _version)) ) ;  // PRQA S 3050, 3081
        }
        else { // should not happen - see above exceptions
            p.addParameter( dbParam(dbKey, "t_configurationspaces","version" , dbParam::ISNULL) ) ;
        }
        queryString.addANDWhereParameter(p) ;
    }   

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "file: " << uploadfile ) ;
	

	dbQuery query(conn, queryString, "ConfigurationSpaceUpload") ;	

    query.uploadClob();
}

// Save the file on disk
void dbConfigurationSpace::saveSpaceFile(const string &path, const string &filename, dbConnection &conn)  // PRQA S 4211
{
	Lock lock(*this) ; // PRQA S 3050

	string completePath ;
	if (path != "" && filename != "") {
		completePath = path + "/" + filename ;
    }
	else if (filename != "") {
		completePath = filename ;
    }
	else if (path != "") {
		completePath = path ;
    }
	else {
		completePath = getSpaceFileName() ;
    }

	if(isFromDatabase()) {
    

        const string & dbKey = conn.getKey() ;
        
        SQLString queryString(dbKey, SQLString::LOBJ_DOWNLOAD ) ;
        queryString.setColumnAndFileName( "Space", completePath );
        queryString.addTableList( getTable() );
        
        {
            dbQueryParameters p(dbKey) ;
            if(_namespaceSet) {
                p.addParameter( dbParam(dbKey, "t_configurationspaces","namespace" , dbParam::EQUAL_TO, dbConv(dbKey, _namespace)) ) ;  // PRQA S 3050, 3081
            }
            else {
                p.addParameter( dbParam(dbKey, "t_configurationspaces","namespace" , dbParam::ISNULL) ) ;
            }
            queryString.addANDWhereParameter(p) ;
        }
            
        {
            dbQueryParameters p(dbKey) ;
            if(_versionSet) {
                p.addParameter( dbParam(dbKey, "t_configurationspaces","version" , dbParam::EQUAL_TO, dbConv(dbKey, _version)) ) ;  // PRQA S 3050, 3081
            }
            else {
                p.addParameter( dbParam(dbKey, "t_configurationspaces","version" , dbParam::ISNULL) ) ;
            }
            queryString.addANDWhereParameter(p) ;
        }   
	    
        ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "Downloading file: " << completePath) ;


        dbQuery query(conn, queryString, getTable() + " clob dwnl" ) ;	

        query.downloadClob();

		// change permissions allowing other users to override this file later.
		if ((File::getmod(completePath) & 0664) == 0) { // PRQA S 4400 2
            File::chmod(completePath,0664) ;
        }

	} 
	else
	{
		int err = ::link(getSpaceFileName().c_str(),completePath.c_str()) ;
		if(err != 0) {	
			string str = "Cannot copy \"" + getSpaceFileName() + "\" on \"" + completePath + "\"";
			exFileOpenException e(str , errno) ;
			ACS_THROW (e) ;
		}
	} // if(isFromDatabase()) 
}

// by definition: <namespace>_<version>.<ext>
string dbConfigurationSpace::getSpaceFileName() const 
{
	Lock lock(*this) ; // PRQA S 3050

	return ResourceSpace::buildPathWithoutExtension(_namespace,_version) + ".xml";
}

void dbConfigurationSpace::setSpaceUploadFileName(const string &uf)
{
	Lock lock(*this) ; // PRQA S 3050

	_spaceUploadFileName = uf ;
	_spaceUploadFileNameSet = true ;
}

string dbConfigurationSpace::getSpaceUploadFileName(bool *set) const
{
	Lock lock(*this) ; // PRQA S 3050

	if (set) {
		*set = _spaceUploadFileNameSet ;
    }
	return _spaceUploadFileName ;
}


// get the field names
string dbConfigurationSpace::getFields()
{
	string s ;
	s += getTable() + "." + "Namespace, ";
	s += getTable() + "." + "Version" ;
	return s ;
}


// get the table name
string dbConfigurationSpace::getTable()
{
	return "T_ConfigurationSpaces" ;
}


// get the order by clause
string dbConfigurationSpace::getOrderBy()
{
	return "Namespace, Version DESC" ;
}


void dbConfigurationSpace::writeTo(ostream &o) const
{
	Lock lock(*this) ; // PRQA S 3050
    writeToM(o, _namespaceSet, _namespace) ;
    writeToM(o, _versionSet, _version) ;
}


void dbConfigurationSpace::writeTo(exostream &o) const
{
	Lock lock(*this) ; // PRQA S 3050
    writeToM(o, _namespaceSet, _namespace) ;
    writeToM(o, _versionSet, _version) ;
}




_ACS_END_NAMESPACE

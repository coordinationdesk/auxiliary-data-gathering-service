// PRQA S 1050 EOF
/*

	Copyright 1995-2021, Advanced Computer Systems , Inc.
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.acsys.it

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Advanced Computer Systems;
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Advanced Computer Systems, Inc.

	$Prod: A.C.S. Db Cryosat Library $

	$Id$

	$Author$

	$Log$
	Revision 5.5  2016/04/11 13:27:13  marpas
	adopting new db interfaces
	
	Revision 5.4  2016/03/26 21:42:59  marpas
	using new db I/F
	
	Revision 5.3  2016/03/22 17:17:05  marpas
	getting rid of obsolescent HMI calls
	
	Revision 5.2  2013/07/22 18:01:03  marpas
	aligning to new libDbData interface
	
	Revision 5.1  2013/06/11 14:27:21  marpas
	coding best practices applied
	
	Revision 5.0  2013/06/11 14:16:32  marpas
	adopting libException 5.x standards
	
	Revision 2.5  2013/06/07 13:43:45  marpas
	using pool if no connection
	
	Revision 2.4  2013/01/23 17:23:09  marpas
	introducing dbConnectionPool for factories
	coding best practices
	interface rationalization
	qa rules
	
	Revision 2.3  2012/02/13 16:53:02  marpas
	refactoring
	
	Revision 2.2  2009/03/30 17:48:54  marpas
	robust implementation
	rules ...
	
	Revision 2.1  2008/11/13 12:47:55  marpas
	porting toward db-independence
	
	Revision 2.0  2006/02/28 09:09:03  marpas
	Exception 2.1 I/F adopted
	
	Revision 1.3  2006/01/04 16:44:08  enrcar
	Updated to DBEXPRESS environment
	
	Revision 1.2  2005/10/11 08:08:13  enrcar
	getParameters() method used
	
	Revision 1.1  2005/07/21 10:24:43  marpas
	dbConfigurationSpace and its query imported from libDbCryosat
	
	Revision 1.22  2005/03/09 18:03:23  marpas
	some messages fixed
	namespaces fixed
	
	Revision 1.21  2004/09/22 14:58:39  ivafam
	If in _orderByString clause "ORDER BY" is present do not add clause
	
	Revision 1.20  2004/09/22 13:20:07  ivafam
	Bug Fixed in do query: Now the SQLCLAUSE "ORDER BY" is added if _orderByString
	is not empty.
	
	Revision 1.19  2004/08/30 17:51:13  paoscu
	doQuery abstract I/F changed
	
	Revision 1.18  2004/04/28 13:08:40  paoscu
	Incremental query support.
	
	Revision 1.17  2004/04/13 16:52:56  paoscu
	Copy constructor and operator= added
	clone() method added.
	
	Revision 1.16  2004/02/04 10:12:35  paoscu
	Library generated again. dbPersistent interface changed.
		

*/

// This file is automatically generated by dbGenerator tool

#include <dbConfigurationSpaceQuery.h>
#include <dbConfigurationSpace.h>
#include <dbQuery.h>
#include <dbRow.h>
#include <dbSet.h>
#include <dbPersistentFactoryChain.h>
#include <sstream>



_ACS_BEGIN_NAMESPACE(acs)

using namespace std ;



ACS_CLASS_DEFINE_DEBUG_LEVEL(dbConfigurationSpaceQuery)

string dbConfigurationSpaceQuery::staticClassName()
{
	return "dbConfigurationSpaceQuery" ;
}



// constructor
dbConfigurationSpaceQuery::dbConfigurationSpaceQuery(const std::string &dbKey) :
    dbGeneralQuery(dbKey)
{
}


dbConfigurationSpaceQuery::dbConfigurationSpaceQuery(dbConfigurationSpaceQuery const &rhs) :
    dbGeneralQuery(rhs)
{
}

dbConfigurationSpaceQuery &dbConfigurationSpaceQuery::operator=(dbConfigurationSpaceQuery const &other)
{
	if(this != &other)
	{
		// thread safety
		Lock lock1(*this) ; // PRQA S 3050 2
		Lock lock2(other) ;
		
		// copies values
		dbGeneralQuery::operator=(other) ;
	}
	
	return *this ;
}


dbGeneralQueryIF * dbConfigurationSpaceQuery::clone() const
{
	return new dbConfigurationSpaceQuery(*this) ;
}


dbConfigurationSpaceQuery::~dbConfigurationSpaceQuery() throw() {}



unsigned long dbConfigurationSpaceQuery::doQuery(dbConnection &conn, bool incremental, bool enabled) // PRQA S 4020
{
	if(incremental)
	{
		// no incremental allowed
		InvalidUse e("Incremental query not allowed.") ;
		ACS_THROW(e) ;
	}

	clear() ; // erase previous result set
	// no result: not enabled
	if(!enabled) {
		return 0;
    }

	// prepare the SQL string
    SQLString queryString = _sqlString ;
    queryString.setType( SQLString::SELECT );
    if (maxItems() > 0) {
		queryString.setLimit( maxItems() ) ; // PRQA S 3000
    }

    queryString.addSelectList( dbConfigurationSpace::getFields() );
    queryString.addTableList( dbConfigurationSpace::getTable() );

	// where parameters and orderby have been copied from _sqlString above 

	ACS_CLASS_WRITE_DEBUG(ACS_LOW_VERB, "Query string is : \"" << queryString.getSQL() << "\"") ;

	// build the query
	dbQuery query(conn, queryString, "ConfigurationSpacesQuery") ;

	// execute
	dbSet set ;

	query.execForSet(set) ;

	// loop to load result
	dbRow row(conn.getKey()) ;
	for (size_t i=0; set.getNextRow(row); i++)  // PRQA S 4238
	{
		dbConfigurationSpace *record = 0 ;

		ACS_CLASS_WRITE_DEBUG(ACS_LOW_VERB, "Added a new ConfigurationSpace") ;
		// record = new dbConfigurationSpace ;
		record=dynamic_cast<dbConfigurationSpace*>( dbPersistentFactoryChain::instance()->newObject("dbConfigurationSpace", conn.getKey())) ; // PRQA S 3081, 4412
		try{
			record->loadRow(row,0) ;
		}
		catch(...){
			delete record;
			throw;
		}
		// correctly loaded - push it into results
		_objects.push_back(record) ;
	}

	// return number of results
	return size() ;
}


dbConfigurationSpace *dbConfigurationSpaceQuery::operator[](unsigned long i)
{
	return dynamic_cast<dbConfigurationSpace *>(item(i)) ;  // PRQA S 3081
}

const dbConfigurationSpace *dbConfigurationSpaceQuery::operator[](unsigned long i) const
{
	return dynamic_cast<const dbConfigurationSpace *>(item(i)) ;  // PRQA S 3081
}



_ACS_END_NAMESPACE

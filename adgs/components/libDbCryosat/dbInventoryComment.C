/*

	Copyright 1995-2021, Exprivia SpA.
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.exprivia.com

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Exprivia SpA;
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Exprivia, Inc.

	$Prod: A.C.S. Db Cryosat Library $

	$Id$

	$Author$

	$Log$
	Revision 6.1  2016/07/27 08:33:15  damdec
	CSGACS-86: Compilation warnings fixed.
	
	Revision 6.0  2016/07/07 13:44:04  damdec
	CSGACQ-82: special queries modified to be compatible with Oracle
	
	Revision 5.4  2016/05/10 21:19:54  danalt
	use of ACS_THROW and ACS_COND_THROW
	
	Revision 5.3  2016/04/19 13:53:47  marpas
	coding best practice application in progress
	useless virtual filedName method removed
	
	Revision 5.2  2016/04/11 13:28:13  marpas
	adopting new db interfaces
	coding best practices application in progress
	
	Revision 5.1  2016/03/26 21:42:50  marpas
	using new db I/F
	
	Revision 5.0  2015/02/17 11:25:25  marfav
	Field unique_id added to table t_smactions
	
	Revision 4.0  2013/09/30 12:30:56  marpas
	the following classes have been removed:
	dbDistributionPolicy
	dbDistributionPolicyQuery
	dbIORepository
	dbIORepositoryQuery
	dbReceptionPolicy
	dbReceptionPolicyQuery
	
	Revision 3.0  2013/09/19 14:57:24  marfav
	dbSMactions now include inventory id pointers
	
	Revision 2.12  2013/04/12 12:14:38  marpas
	SQLDialectFactory::dialectName() needs a db connection key
	
	Revision 2.11  2013/03/29 19:51:29  marpas
	removing html related functions
	
	Revision 2.10  2012/11/16 13:01:13  marpas
	realignement of MAIN STREAM
	Introducing ADCS1FixedHeaderFactory class
	
	Revision 2.8  2012/02/14 12:52:47  marpas
	 refactoring and introducing dbInventory::uniqueId
	
	Revision 2.7  2011/03/02 18:47:14  marpas
	serial 8 support
	
	Revision 2.6  2010/05/07 16:28:45  marpas
	db independence chould be complete now
	
	Revision 2.5  2010/03/05 15:09:10  enrcar
	EC:: Oracle11 dialect supported whenever no specific code was required (was: Postgres8 || Informix9)
	
	Revision 2.4  2008/11/17 11:46:28  marpas
	column name changed (text into comment)
	
	Revision 2.3  2008/09/17 15:45:17  crivig
	porting to postgres8
	
	Revision 2.2  2006/06/09 12:45:58  giucas
	Fixed syntax error in update query.
	
	Revision 2.1  2006/06/09 11:53:21  giucas
	Update method fixed.
	
	Revision 2.0  2006/02/28 09:09:35  marpas
	Exception 2.1 I/F adopted
	
	Revision 1.32  2005/06/15 07:44:50  integrator
	multiple storage manager implemented
	
	Revision 1.31  2005/03/09 18:03:23  marpas
	some messages fixed
	namespaces fixed
	
	Revision 1.30  2005/03/04 22:49:07  marpas
	dbWaitingOrder and dbWaitingOrderQuery classes  and their tests added , db_values script updated accordingly
	
	Revision 1.29  2004/10/04 15:13:53  ivafam
	When set orderBy control if orderBySQLDString contain already clause "ORDER BY"
	
	Revision 1.28  2004/07/13 15:15:44  paoscu
	using namespace std no longer in includes
	exDbPersistent is an abstract class
	
	Revision 1.27  2004/07/07 10:34:32  paoscu
	dbPersistent I/F chnaged
	
	Revision 1.26  2004/05/03 14:55:34  paoscu
	Paramer "id" removed in method "remove"
	
	Revision 1.25  2004/04/16 12:49:34  paoscu
	Bug fixed in Lock usage
	
	Revision 1.24  2004/04/13 16:57:08  paoscu
	ThreadSafe::Lock used.
	clobe() method added.
	
	Revision 1.23  2004/02/04 10:12:35  paoscu
	Library generated again. dbPersistent interface changed.
		

*/

// This file is automatically generated by dbGenerator tool

#include <dbInventoryComment.h>
#include <dbQuery.h>
#include <dbRow.h>
#include <dbSet.h>
#include <dbConv.h>
#include <rsResourceSet.h>
#include <rsPushNSpace.h>
#include <sstream>
#include <XMLOstream.h>



using namespace acs ;
using namespace std ;



ACS_CLASS_DEFINE_DEBUG_LEVEL(dbInventoryComment)

// constructor
dbInventoryComment::dbInventoryComment() :
	dbPersistent(),
	_comment(),
	_commentSet(),
	_date(),
	_dateSet(),
	_author(),
	_authorSet(),
	_fileName(),
	_fileNameSet(),
	_fileVersion(),
	_fileVersionSet()

{
	reset() ;
}


// copy constructor
dbInventoryComment::dbInventoryComment(const dbInventoryComment &o):
	dbPersistent(o),
	_comment(o._comment),
	_commentSet(o._commentSet),
	_date(o._date),
	_dateSet(o._dateSet),
	_author(o._author),
	_authorSet(o._authorSet),
	_fileName(o._fileName),
	_fileNameSet(o._fileNameSet),
	_fileVersion(o._fileVersion),
	_fileVersionSet(o._fileVersionSet)
{
}


dbInventoryComment::~dbInventoryComment() throw()
{
}



dbPersistent *dbInventoryComment::clone() const
{
	return new dbInventoryComment(*this) ;
}


// operator =
dbInventoryComment &dbInventoryComment::operator=(const dbInventoryComment &o)
{
	Lock lock(*this) ;

	if(this != &o)
	{
		dbPersistent::operator=(o) ;
		_comment=o._comment;
		_commentSet=o._commentSet;
		_date=o._date;
		_dateSet=o._dateSet;
		_author=o._author;
		_authorSet=o._authorSet;
		_fileName=o._fileName;
		_fileNameSet=o._fileNameSet;
		_fileVersion=o._fileVersion;
		_fileVersionSet=o._fileVersionSet;
	}
	return *this ;
}


string dbInventoryComment::className() const
{
	return staticClassName() ;
}


string dbInventoryComment::staticClassName()
{
	return "dbInventoryComment" ;
}


// initialize the class
void dbInventoryComment::reset()
{
	Lock lock(*this) ;

	// reset dbPersistent
	dbPersistent::reset() ;
	_comment="" ;
	_commentSet=false ;
	_date.reset() ;
	_dateSet=false ;
	_author="" ;
	_authorSet=false ;
	_fileName="" ;
	_fileNameSet=false ;
	_fileVersion="" ;
	_fileVersionSet=false ;
}


// save the data in database
dbPersistent::IdType dbInventoryComment::save(dbConnection &conn)
{
	Lock lock(*this) ;

	if (!isModified())
		return 0 ; 

	if (isFromDatabase()) 
	{
		InvalidUse e("Error: dbInventoryComment::save(). Use the method update() instead of save().") ;
		ACS_THROW(e) ;
	}
	if(!_commentSet) 
	{
		InvalidUse e("Mandatory field \"Comment\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_authorSet) 
	{
		InvalidUse e("Mandatory field \"Author\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_fileNameSet) 
	{
		InvalidUse e("Mandatory field \"File Name\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_fileVersionSet) 
	{
		InvalidUse e("Mandatory field \"File Version\" must be set.") ;
		ACS_THROW(e) ;
	}

	const string &dbKey = conn.getKey() ;
    SQLString queryString(dbKey, SQLString::INSERT ) ;
    queryString.addTableList(getTable());
    queryString.addValuesList("comment", db::toSQL(dbKey,_comment) ) ;
	if(_dateSet) 
	{
        queryString.addValuesList("date", db::toSQL(dbKey,_date,dbConv::YearToFraction) ) ;
	}
    queryString.addValuesList("author", db::toSQL(dbKey,_author) ) ;
    queryString.addValuesList("filename", db::toSQL(dbKey,_fileName) ) ;
    queryString.addValuesList("fileversion", db::toSQL(dbKey,_fileVersion) ) ;
	dbQuery query(conn, queryString, getTable()+"_Insert") ;

	if (!query.execForStatus())
	{
		dbQuery::QueryExecuteException e(string("Query Execution error: Command : ")
		+ string(queryString.getSQL())
		+ string(" Error : ")
		+ string(query.errorString())) ;
		ACS_THROW (e) ;
	}

    // obtain the last serial just inserted
    setId( getLastSerial(conn, getTable()) ) ; // PRQA S 3380

    // reload from the database (read auto generated fileds, if any)
    // this will also set "from database" to true
    load (conn);
   
    return getId() ;
}


// load the class from the database. Return true if object exist
bool dbInventoryComment::load(dbConnection &conn , IdType id)
{
	Lock lock(*this) ;

	dbInventoryComment tempRecord(*this); //store current record.


    IdType loadId = id ;
    if(loadId == 0) 
    {
        loadId=getId() ;
    }
    ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "called with id=" << id << " getId():" << getId() << " Id:" << loadId) ;


	reset() ; 

	ACS_CLASS_ANNOUNCE_DEBUG(ACS_VLO_VERB) ;

	const string &dbKey = conn.getKey() ;
	SQLString sqlstring(dbKey, SQLString::SELECT ) ;
	getFields(&sqlstring) ;
	sqlstring.addTableList(getTable());

    dbQueryParameters pp(dbKey) ;
	pp.addParameter(dbParam(dbKey,getTable(),"id_inventorycomment" ,dbParam::EQUAL_TO , db::toSQL(dbKey,loadId) )) ;
	sqlstring.addANDWhereParameter(pp) ;

	dbQuery query(conn, sqlstring, getTable() + "_Load") ;
	dbRow row(conn.getKey()) ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "SQL command : " << sqlstring.getSQL() ) ;

    dbSet set;
	query.execForSet(set);
    if (set.size() > 1)
    {
        // it should not occur
        ACS_THROW(exIllegalValueException("Unexpected query result: it should return just one row."));
    }
    if(not set.getNextRow(row))
    {
		*this = tempRecord;  //Nothing found: restore previuos situation.
		return false ;
    }

	loadRow(row, 0) ;

	setFromDatabase() ;

	resetModifiedFlag() ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "Dump : \"" << *this) ;

	return true;
}


// update an existing instance in database
dbPersistent::IdType dbInventoryComment::update(dbConnection &conn)
{
	Lock lock(*this) ;

	if (!isFromDatabase())
	{
		ObjectNotLoaded ex("Error: dbInventoryComment::update(). Use the method save() instead of update().") ; 
		ACS_THROW(ex)
	}

	if (!isModified())
		return 0 ; 

	const string &dbKey = conn.getKey() ;
   	SQLString queryString(dbKey, SQLString::UPDATE) ;

   	queryString.addTableList( getTable()) ;
	queryString.addSetList("FileName",  db::toSQL(dbKey,_fileName)) ;
	queryString.addSetList("FileVersion", db::toSQL(dbKey,_fileVersion)) ;
	queryString.addSetList("comment", db::toSQL(dbKey,_comment)) ;
	queryString.addSetList("date", db::toSQL(dbKey,_date,dbConv::YearToFraction)) ;
	queryString.addSetList("author", db::toSQL(dbKey,_author)) ;
    
    dbQueryParameters pars(dbKey) ;

    pars.addParameter(dbParam(dbKey,getTable(),"id_inventorycomment", dbParam::EQUAL_TO, db::toSQL(dbKey,getId()))) ;
    queryString.addANDWhereParameter(pars) ;

	dbQuery query(conn, queryString, getTable()+"_Update") ;

	query.execForStatus() ;

	resetModifiedFlag() ;
	return 0 ;

}


// remove the class from the database
dbPersistent::IdType dbInventoryComment::remove(dbConnection &conn)
{
	Lock lock(*this) ;
    
    if (!isFromDatabase())
    {
        ObjectNotLoaded ex("Error: dbInventoryComment::remove() cannot be used if the record is not in the database.") ; 
        ACS_THROW(ex)
    }

	const string &dbKey = conn.getKey() ;
	SQLString sqlString ( dbKey, SQLString::DELETE ) ;
	sqlString.addTableList(getTable()) ;
	{
		dbQueryParameters pp(dbKey) ;
		// Add where
		pp.addParameter(dbParam(dbKey, getTable(), "id_inventorycomment" , dbParam::EQUAL_TO , db::toSQL(dbKey, getId()) )) ;
		sqlString.addANDWhereParameter(pp) ;
	}

	dbQuery query(conn, sqlString, "dbInventoryComment::remove") ;

	query.execForStatus() ;

	resetFromDatabase() ;
	setModifiedFlag() ;

	return 0 ;
}


// True if the class have valid parameters, false otherwise
bool dbInventoryComment::validate() const
{
	Lock lock(*this) ;

	return true;
}


// export the class to stream
void dbInventoryComment::exportObj(rsResourceSet &s) const
{
	Lock lock(*this) ;

	rsPushNSpace nsp(s,"dbInventoryComment") ;
	dbPersistent::exportObj(s) ;
	if(_commentSet)
	{
		s.setValue("_comment",_comment) ;
	}
	s.setValue("_commentSet",_commentSet) ;
	if(_dateSet)
	{
		{
		rsPushNSpace rpns1(s,"_date") ;
		_date.exportObj(s) ;
		}
	}
	s.setValue("_dateSet",_dateSet) ;
	if(_authorSet)
	{
		s.setValue("_author",_author) ;
	}
	s.setValue("_authorSet",_authorSet) ;
	if(_fileNameSet)
	{
		s.setValue("_fileName",_fileName) ;
	}
	s.setValue("_fileNameSet",_fileNameSet) ;
	if(_fileVersionSet)
	{
		s.setValue("_fileVersion",_fileVersion) ;
	}
	s.setValue("_fileVersionSet",_fileVersionSet) ;
}


// import the class from a stream
void dbInventoryComment::importObj(rsResourceSet &s)
{
	Lock lock(*this) ;

	rsPushNSpace nsp(s,"dbInventoryComment") ;
	dbPersistent::importObj(s) ;
	s.getValue("_commentSet",_commentSet) ;
	if(_commentSet)
	{
		s.getValue("_comment",_comment) ;
	}
	else
		_comment = "" ;
	s.getValue("_dateSet",_dateSet) ;
	if(_dateSet)
	{
		{
		rsPushNSpace rpns1(s,"_date") ;
		_date.importObj(s) ;
		}
	}
	else
		_date.reset() ;
	s.getValue("_authorSet",_authorSet) ;
	if(_authorSet)
	{
		s.getValue("_author",_author) ;
	}
	else
		_author = "" ;
	s.getValue("_fileNameSet",_fileNameSet) ;
	if(_fileNameSet)
	{
		s.getValue("_fileName",_fileName) ;
	}
	else
		_fileName = "" ;
	s.getValue("_fileVersionSet",_fileVersionSet) ;
	if(_fileVersionSet)
	{
		s.getValue("_fileVersion",_fileVersion) ;
	}
	else
		_fileVersion = "" ;
}


// export the class to XML stream
void dbInventoryComment::exportXML(XMLOstream &xst) const
{
	Lock lock(*this) ;

	XMLOstream::Tag txml(xst, "dbInventoryComment");
	dbPersistent::exportXML(xst) ;
	if(_commentSet)
	{
	XMLOstream::Tag txml0(xst, "_comment", _comment, "label=\"Comment\"");
	}
	else
	{
	XMLOstream::Tag txml0(xst, "_comment", string("<null>"), "label=\"Comment\"");
	}
	{
	XMLOstream::Tag txml0Set(xst, "_commentSet", (_commentSet ? "true" : "false")) ;
	}
	if(_dateSet)
	{
		XMLOstream::Tag txml1(xst, "_date", "", "label=\"Date\"");
		_date.exportXML(xst) ;
	}
	else
	{
	XMLOstream::Tag txml1(xst, "_date", string("<null>"), "label=\"Date\"");
	}
	{
	XMLOstream::Tag txml1Set(xst, "_dateSet", (_dateSet ? "true" : "false")) ;
	}
	if(_authorSet)
	{
	XMLOstream::Tag txml2(xst, "_author", _author, "label=\"Author\"");
	}
	else
	{
	XMLOstream::Tag txml2(xst, "_author", string("<null>"), "label=\"Author\"");
	}
	{
	XMLOstream::Tag txml2Set(xst, "_authorSet", (_authorSet ? "true" : "false")) ;
	}
	if(_fileNameSet)
	{
	XMLOstream::Tag txml3(xst, "_fileName", _fileName, "label=\"File Name\"");
	}
	else
	{
	XMLOstream::Tag txml3(xst, "_fileName", string("<null>"), "label=\"File Name\"");
	}
	{
	XMLOstream::Tag txml3Set(xst, "_fileNameSet", (_fileNameSet ? "true" : "false")) ;
	}
	if(_fileVersionSet)
	{
	XMLOstream::Tag txml4(xst, "_fileVersion", _fileVersion, "label=\"File Version\"");
	}
	else
	{
	XMLOstream::Tag txml4(xst, "_fileVersion", string("<null>"), "label=\"File Version\"");
	}
	{
	XMLOstream::Tag txml4Set(xst, "_fileVersionSet", (_fileVersionSet ? "true" : "false")) ;
	}
}


// load the object from a row
int dbInventoryComment::loadRow(const dbRow &row, int offset)
{
	Lock lock(*this) ;
    uint16_t loff = offset ; 
    
    IdType id = 0 ;
    bool set = false ;
    row.columnSet(loff++, id, set) ; 
    setId(id) ;

	row.columnSet(loff++, _comment, _commentSet) ;
	row.columnSet(loff++, _date, _dateSet) ;
	row.columnSet(loff++, _author, _authorSet) ;
	row.columnSet(loff++, _fileName, _fileNameSet) ;
	row.columnSet(loff++, _fileVersion, _fileVersionSet) ;

	setFromDatabase() ;

	return loff ;
}


void dbInventoryComment::setComment(const string &v)
{
	Lock lock(*this) ;

	if (isFromDatabase())
	{
		InvalidUse e("Error: dbInventoryComment::setComment(). Primary Key is from Database.") ;
		ACS_THROW(e) ;
	}

	if (v.size() > 128)
	{
		InvalidUse e("Error: dbInventoryComment::setComment(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_commentSet || _comment != v ) 
	{
		_comment = v ;
		_commentSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbInventoryComment::getComment(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _commentSet ;
	return _comment ;
}


void dbInventoryComment::unsetComment()
{
	if (isFromDatabase())
	{
		InvalidUse e("Error: dbInventoryComment::unsetComment(). Primary Key is from Database.") ;
		ACS_THROW(e) ;
	}

	Lock lock(*this) ;
	if(_commentSet == true)
		setModifiedFlag();
	_commentSet = false;

}
void dbInventoryComment::setDate(const DateTime &v)
{
	Lock lock(*this) ;

	if (isFromDatabase())
	{
		InvalidUse e("Error: dbInventoryComment::setDate(). Primary Key is from Database.") ;
		ACS_THROW(e) ;
	}

	if (!_dateSet || _date != v ) 
	{
		_date = v ;
		_dateSet = true ;
		setModifiedFlag() ;
	}
}


const DateTime &dbInventoryComment::getDate(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _dateSet ;
	return _date ;
}


void dbInventoryComment::unsetDate()
{
	if (isFromDatabase())
	{
		InvalidUse e("Error: dbInventoryComment::unsetDate(). Primary Key is from Database.") ;
		ACS_THROW(e) ;
	}

	Lock lock(*this) ;
	if(_dateSet == true)
		setModifiedFlag();
	_dateSet = false;

}
void dbInventoryComment::setAuthor(const string &v)
{
	Lock lock(*this) ;

	if (isFromDatabase())
	{
		InvalidUse e("Error: dbInventoryComment::setAuthor(). Primary Key is from Database.") ;
		ACS_THROW(e) ;
	}

	if (v.size() > 32)
	{
		InvalidUse e("Error: dbInventoryComment::setAuthor(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_authorSet || _author != v ) 
	{
		_author = v ;
		_authorSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbInventoryComment::getAuthor(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _authorSet ;
	return _author ;
}


void dbInventoryComment::unsetAuthor()
{
	if (isFromDatabase())
	{
		InvalidUse e("Error: dbInventoryComment::unsetAuthor(). Primary Key is from Database.") ;
		ACS_THROW(e) ;
	}

	Lock lock(*this) ;
	if(_authorSet == true)
		setModifiedFlag();
	_authorSet = false;

}
void dbInventoryComment::setFileName(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 128)
	{
		InvalidUse e("Error: dbInventoryComment::setFileName(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_fileNameSet || _fileName != v ) 
	{
		_fileName = v ;
		_fileNameSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbInventoryComment::getFileName(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _fileNameSet ;
	return _fileName ;
}


void dbInventoryComment::unsetFileName()
{
	Lock lock(*this) ;
	if(_fileNameSet == true)
		setModifiedFlag();
	_fileNameSet = false;

}
void dbInventoryComment::setFileVersion(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 8)
	{
		InvalidUse e("Error: dbInventoryComment::setFileVersion(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_fileVersionSet || _fileVersion != v ) 
	{
		_fileVersion = v ;
		_fileVersionSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbInventoryComment::getFileVersion(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _fileVersionSet ;
	return _fileVersion ;
}


void dbInventoryComment::unsetFileVersion()
{
	Lock lock(*this) ;
	if(_fileVersionSet == true)
		setModifiedFlag();
	_fileVersionSet = false;

}
// get the field names
string dbInventoryComment::getFields(SQLString *select)
{
	
	string s ;
	s += getTable() + "." + "id_inventorycomment, "; if (select) select->addSelectList(getTable() + "." + "id_inventorycomment") ;
	s += getTable() + "." + "Comment, "; if (select) select->addSelectList(getTable() + "." + "comment") ;
	s += getTable() + "." + "Date, "; if (select) select->addSelectList(getTable() + "." + "date") ;
	s += getTable() + "." + "Author, "; if (select) select->addSelectList(getTable() + "." + "author") ;
	s += getTable() + "." + "FileName, "; if (select) select->addSelectList(getTable() + "." + "filename") ;
	s += getTable() + "." + "FileVersion" ; if (select) select->addSelectList(getTable() + "." + "fileversion") ;
	return s ;
}


// get the table name
string dbInventoryComment::getTable()
{
	return "t_inventorycomments" ;
}


// get the order by clause
string dbInventoryComment::getOrderBy(SQLString *select)
{
	if (select) {
		select->addOrderByList(getTable()+".comment", SQLString::DESC) ;
		select->addOrderByList(getTable()+".date", SQLString::DESC) ;
		select->addOrderByList(getTable()+".author", SQLString::DESC) ;
	}
	return "Comment, Date, Author DESC" ;
}


void dbInventoryComment::writeTo(ostream &o) const
{
	Lock lock(*this) ;

	string tmp ; 

	o
		 << "_id = " << getId() << "\n"
		 << "_comment = " << (_commentSet ? _comment : string("<null>")) << "\n" 
		 << "_date = " << (_dateSet ? _date.utcs(tmp) : string("<null>")) << "\n" 
		 << "_author = " << (_authorSet ? _author : string("<null>")) << "\n" 
		 << "_fileName = " << (_fileNameSet ? _fileName : string("<null>")) << "\n" 
		 << "_fileVersion = " << (_fileVersionSet ? _fileVersion : string("<null>")) << "\n"  ;
}


void dbInventoryComment::writeTo(exostream &o) const
{
	Lock lock(*this) ;

	string tmp ; 

	o
		 << "_id = " << getId() << "\n"
		 << "_comment = " << (_commentSet ? _comment : string("<null>")) << "\n" 
		 << "_date = " << (_dateSet ? _date.utcs(tmp) : string("<null>")) << "\n" 
		 << "_author = " << (_authorSet ? _author : string("<null>")) << "\n" 
		 << "_fileName = " << (_fileNameSet ? _fileName : string("<null>")) << "\n" 
		 << "_fileVersion = " << (_fileVersionSet ? _fileVersion : string("<null>")) << "\n"  ;
}



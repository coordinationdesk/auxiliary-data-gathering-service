/*

	Copyright 1995-2021, Advanced Computer Systems , Inc.
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.acsys.it

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Advanced Computer Systems;
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Advanced Computer Systems, Inc.

	$Prod: A.C.S. Db Cryosat Library $

	$Id$

	$Author$

	$Log$
	Revision 7.0  2017/05/31 17:32:59  nicvac
	OPMAN-260: Need PDS DB schema PDS_12-04.
	
	Revision 6.0  2016/07/07 13:44:04  damdec
	CSGACQ-82: special queries modified to be compatible with Oracle
	
	Revision 5.5  2016/05/10 21:19:54  danalt
	use of ACS_THROW and ACS_COND_THROW
	
	Revision 5.4  2016/04/19 13:53:47  marpas
	coding best practice application in progress
	useless virtual filedName method removed
	
	Revision 5.3  2016/04/18 15:22:52  marpas
	coding best practices application in progress
	
	Revision 5.2  2016/04/11 13:28:14  marpas
	adopting new db interfaces
	coding best practices application in progress
	
	Revision 5.1  2016/03/26 21:42:50  marpas
	using new db I/F
	
	Revision 5.0  2015/02/17 11:25:26  marfav
	Field unique_id added to table t_smactions
	
	Revision 4.1  2014/05/26 11:39:45  marpas
	dbConv casted to avoid problem with new libXMLResources templates for tags
	
	Revision 4.0  2013/09/30 12:31:01  marpas
	the following classes have been removed:
	dbDistributionPolicy
	dbDistributionPolicyQuery
	dbIORepository
	dbIORepositoryQuery
	dbReceptionPolicy
	dbReceptionPolicyQuery
	
	Revision 3.0  2013/09/19 14:57:29  marfav
	dbSMactions now include inventory id pointers
	
	Revision 2.12  2013/04/30 13:31:42  marpas
	dbPersistent interface changed
	
	Revision 2.11  2013/04/17 17:37:24  marpas
	dbPersistent interface changed
	
	Revision 2.10  2013/04/12 12:14:39  marpas
	SQLDialectFactory::dialectName() needs a db connection key
	
	Revision 2.9  2013/03/29 19:51:30  marpas
	removing html related functions
	
	Revision 2.8  2013/02/22 11:58:55  marpas
	using StringUtils::findNoCase
	
	Revision 2.7  2012/11/16 13:01:14  marpas
	realignement of MAIN STREAM
	Introducing ADCS1FixedHeaderFactory class
	
	Revision 2.5  2012/02/14 12:52:49  marpas
	 refactoring and introducing dbInventory::uniqueId
	
	Revision 2.4  2011/03/02 18:47:14  marpas
	serial 8 support
	
	Revision 2.3  2010/03/05 15:09:11  enrcar
	EC:: Oracle11 dialect supported whenever no specific code was required (was: Postgres8 || Informix9)
	
	Revision 2.2  2009/09/29 15:34:32  marpas
	useless include removed
	
	Revision 2.1  2008/09/17 09:32:27  crivig
	porting to postgres8
	
	Revision 2.0  2006/02/28 09:09:36  marpas
	Exception 2.1 I/F adopted
	
	Revision 1.39  2005/06/15 07:44:50  integrator
	multiple storage manager implemented
	
	Revision 1.38  2005/06/06 12:40:39  danben
	update bug fixed
	
	Revision 1.37  2005/06/06 10:24:10  marpas
	processorconfiguration field can be empty string not null
	
	Revision 1.36  2005/06/06 09:47:24  marpas
	processor configuration can be NULL
	
	Revision 1.35  2005/03/09 18:03:24  marpas
	some messages fixed
	namespaces fixed
	
	Revision 1.34  2005/03/04 22:49:07  marpas
	dbWaitingOrder and dbWaitingOrderQuery classes  and their tests added , db_values script updated accordingly
	
	Revision 1.33  2004/10/04 15:13:53  ivafam
	When set orderBy control if orderBySQLDString contain already clause "ORDER BY"
	
	Revision 1.32  2004/10/01 16:50:39  paoscu
	file class added
	
	Revision 1.31  2004/07/13 15:15:44  paoscu
	using namespace std no longer in includes
	exDbPersistent is an abstract class
	
	Revision 1.30  2004/07/07 10:34:32  paoscu
	dbPersistent I/F chnaged
	
	Revision 1.29  2004/05/03 14:55:34  paoscu
	Paramer "id" removed in method "remove"
	
	Revision 1.28  2004/04/16 12:49:34  paoscu
	Bug fixed in Lock usage
	
	Revision 1.27  2004/04/13 16:57:09  paoscu
	ThreadSafe::Lock used.
	clobe() method added.
	
	Revision 1.26  2004/03/09 18:08:31  paoscu
	load fixed
	
	Revision 1.25  2004/03/04 18:55:36  paoscu
	Now primary key is a serial id.
		

*/

// This file is automatically generated by dbGenerator tool

#include <dbOrderGeneration.h>
#include <dbQuery.h>
#include <dbRow.h>
#include <dbSet.h>
#include <dbConv.h>
#include <Transaction.h>
#include <rsResourceSet.h>
#include <rsPushNSpace.h>
#include <sstream>
#include <XMLOstream.h>



using namespace acs ;

using namespace std ;


ACS_CLASS_DEFINE_DEBUG_LEVEL(dbOrderGeneration)

// constructor
dbOrderGeneration::dbOrderGeneration() :
	dbPersistent(),
	_processorName() ,
	_processorNameSet() ,
	_processorVersion() ,
	_processorVersionSet() ,
	_processorConfiguration() ,
	_processorConfigurationSet() ,
	_algorithm() ,
	_algorithmSet() ,
	_orderType() ,
	_orderTypeSet() ,
	_fileClass() ,
	_fileClassSet() ,
	_fileType() ,
	_fileTypeSet() ,
	_active() ,
	_activeSet() ,
	_priority() ,
	_prioritySet() ,
	_troubleShooting() ,
	_troubleShootingSet() ,
	_processingTimeWindow() ,
	_processingTimeWindowSet()

{
	reset() ;
}


// copy constructor
dbOrderGeneration::dbOrderGeneration(const dbOrderGeneration &o):
	dbPersistent(o),
	_processorName(o._processorName) ,
	_processorNameSet(o._processorNameSet) ,
	_processorVersion(o._processorVersion) ,
	_processorVersionSet(o._processorVersionSet) ,
	_processorConfiguration(o._processorConfiguration) ,
	_processorConfigurationSet(o._processorConfigurationSet) ,
	_algorithm(o._algorithm) ,
	_algorithmSet(o._algorithmSet) ,
	_orderType(o._orderType) ,
	_orderTypeSet(o._orderTypeSet) ,
	_fileClass(o._fileClass) ,
	_fileClassSet(o._fileClassSet) ,
	_fileType(o._fileType) ,
	_fileTypeSet(o._fileTypeSet) ,
	_active(o._active) ,
	_activeSet(o._activeSet) ,
	_priority(o._priority) ,
	_prioritySet(o._prioritySet) ,
	_troubleShooting(o._troubleShooting) ,
	_troubleShootingSet(o._troubleShootingSet) ,
	_processingTimeWindow(o._processingTimeWindow) ,
	_processingTimeWindowSet(o._processingTimeWindowSet)
{
}


dbOrderGeneration::~dbOrderGeneration() throw()
{
}



dbPersistent *dbOrderGeneration::clone() const
{
	return new dbOrderGeneration(*this) ;
}




// operator =
dbOrderGeneration &dbOrderGeneration::operator=(const dbOrderGeneration &o)
{
	Lock lock(*this) ;

	if(this != &o)
	{
		dbPersistent::operator=(o) ;
		_processorName=o._processorName;
		_processorNameSet=o._processorNameSet;
		_processorVersion=o._processorVersion;
		_processorVersionSet=o._processorVersionSet;
		_processorConfiguration=o._processorConfiguration;
		_processorConfigurationSet=o._processorConfigurationSet;
		_algorithm=o._algorithm;
		_algorithmSet=o._algorithmSet;
		_orderType=o._orderType;
		_orderTypeSet=o._orderTypeSet;
		_fileClass=o._fileClass;
		_fileClassSet=o._fileClassSet;
		_fileType=o._fileType;
		_fileTypeSet=o._fileTypeSet;
		_active=o._active;
		_activeSet=o._activeSet;
		_priority=o._priority;
		_prioritySet=o._prioritySet;
		_troubleShooting=o._troubleShooting;
		_troubleShootingSet=o._troubleShootingSet;
		_processingTimeWindow=o._processingTimeWindow;
		_processingTimeWindowSet=o._processingTimeWindowSet;
	}
	return *this ;
}


string dbOrderGeneration::className() const
{
	return staticClassName() ;
}


string dbOrderGeneration::staticClassName()
{
	return "dbOrderGeneration" ;
}


// initialize the class
void dbOrderGeneration::reset()
{
	Lock lock(*this) ;

	// reset dbPersistent
	dbPersistent::reset() ;
	_processorName="" ;
	_processorNameSet=false ;
	_processorVersion="" ;
	_processorVersionSet=false ;
	_processorConfiguration="" ;
	_processorConfigurationSet=false ;
	_algorithm="" ;
	_algorithmSet=false ;
	_orderType="" ;
	_orderTypeSet=false ;
	_fileClass="" ;
	_fileClassSet=false ;
	_fileType="" ;
	_fileTypeSet=false ;
	_active=true ;
	_activeSet=false ;
	_priority=0 ;
	_prioritySet=false ;
	_troubleShooting=false ;
	_troubleShootingSet=false ;
	_processingTimeWindow=0 ;
	_processingTimeWindowSet=false ;
}


// save the data in database
dbPersistent::IdType dbOrderGeneration::save(dbConnection &conn)
{
	Lock lock(*this) ;

	if (!isModified())
		return getId() ; 

	if (getId() != 0 || isFromDatabase()) 
	{
		InvalidUse e("Error: dbOrderGeneration::save(). Use the method update() instead of save().") ;
		ACS_THROW(e) ;
	}
	if(!_processorNameSet) 
	{
		InvalidUse e("Mandatory field \"Processor Name\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_processorVersionSet) 
	{
		InvalidUse e("Mandatory field \"Processor Version\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_processorConfigurationSet) 
	{
		InvalidUse e("Mandatory field \"Processor Configuration\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_algorithmSet) 
	{
		InvalidUse e("Mandatory field \"Algorithm\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_orderTypeSet) 
	{
		InvalidUse e("Mandatory field \"Order Type\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_fileTypeSet) 
	{
		InvalidUse e("Mandatory field \"File Type\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_prioritySet) 
	{
		InvalidUse e("Mandatory field \"Priority\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_troubleShootingSet) 
	{
		InvalidUse e("Mandatory field \"TroubleShooting\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_processingTimeWindowSet) 
	{
		InvalidUse e("Mandatory field \"Processing Time Window (Days)\" must be set.") ;
		ACS_THROW(e) ;
	}



	// inside a transaction
	db::Transaction transaction(conn) ;
	transaction.begin_work("dbOrderGeneration_SAVE") ;
	conn.addStateWrapper(*this) ;

    const string &dbKey = conn.getKey() ;
	string queryString ;
	const string dialectName = SQLDialectFactory::dialectName(dbKey) ;
	if( dialectName == "Informix9" || dialectName == "Postgres8" || dialectName == "Oracle11" ) {

		queryString = "INSERT INTO " + getTable() + " (" ;
		queryString += "ProcessorName" ;
		queryString += ", ProcessorVersion" ;
		if (_processorConfigurationSet)
			queryString += ", ProcessorConfiguration" ;
		queryString += ", Algorithm" ;
		queryString += ", OrderType" ;
		if (_fileClassSet)
			queryString += ", FileClass" ;
		queryString += ", FileType" ;
		if(_activeSet)
			queryString += ", Active" ;
		queryString += ", Priority" ;
		queryString += ", TroubleShooting" ;
		queryString += ", ProcessingTimeWindow" ;
		queryString +=	") VALUES ( " ;
		queryString +=	db::toSQL(dbKey,_processorName) ;
		queryString +=	", " + string(db::toSQL(dbKey,_processorVersion)) ;
		if (_processorConfigurationSet)
			queryString +=	", " + string(db::toSQL(dbKey,_processorConfiguration)) ;
		queryString +=	", " + string(db::toSQL(dbKey,_algorithm)) ;
		queryString +=	", " + string(db::toSQL(dbKey,_orderType)) ;
		if (_fileClassSet)
			queryString +=	", " + string(db::toSQL(dbKey,_fileClass)) ;
		queryString +=	", " + string(db::toSQL(dbKey,_fileType)) ;
		if(_activeSet)
			queryString +=	", " + string(db::toSQL(dbKey,_active)) ;
		queryString +=	", " + string(db::toSQL(dbKey,_priority)) ;
		queryString +=	", " + string(db::toSQL(dbKey,_troubleShooting)) ;
		queryString +=	", " + string(db::toSQL(dbKey,_processingTimeWindow)) ;
		queryString +=	") " ;

		ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "save called. SQL command : " << queryString) ;
	} else {
		ACS_THROW( exIllegalValueException("Unknown db: "+dialectName ));
	}
	SQLString sqlString(dbKey, SQLString::COMMAND) ;
	sqlString.forceSQLString(queryString) ;
	dbQuery query(conn, sqlString, "dbOrderGeneration::save") ;

	if (!query.execForStatus())
	{
			dbQuery::QueryExecuteException e(string("Query Execution error: Command : ")
			+ string(queryString)
			+ string(" Error : ")
			+ string(query.errorString())) ;
			ACS_THROW (e) ;
	}

	// obtain the last serial just inserted
	setId(getLastSerial(conn, getTable())) ;

    transaction.commit() ;
	setFromDatabase() ; 
	return getId() ;
}


// load the class from the database. Return true if object exist
bool dbOrderGeneration::load(dbConnection &conn , IdType id)
{
	Lock lock(*this) ;

	unsigned long Id=id;
	if(Id == 0) {
		Id=getId() ;
    }
	if(Id==0) 
	{
		IdNotProvided e("Cannot obtain \"Id\"") ;
		ACS_THROW(e) ;
	}

	dbOrderGeneration tempRecord(*this); //store current record.


	reset() ; 

    ACS_CLASS_ANNOUNCE_DEBUG(ACS_VLO_VERB) ;

    const string & dbKey = conn.getKey() ;
	string queryString ;
	const string dialectName = SQLDialectFactory::dialectName(dbKey);
	if( dialectName == "Informix9" || dialectName == "Postgres8" || dialectName == "Oracle11" ) {

		queryString = "SELECT " ;
		queryString +=	getFields() ;
		queryString += " FROM " + getTable() ;
		queryString += " WHERE Id = " ;
		queryString +=	string(db::toSQL(dbKey,Id)) ;
		string getOrderByString(getOrderBy()) ;
		if(!getOrderByString.empty() )
		{
			string orderby= "ORDER BY";
			if(StringUtils::findNoCase(getOrderByString,orderby) != string::npos)
				queryString += getOrderByString ;
			else
				queryString += " ORDER BY " + getOrderByString ;
		}	
	} else {
		ACS_THROW( exIllegalValueException("Unknown db: "+dialectName ));
	}
	SQLString sqlString(dbKey, SQLString::COMMAND) ;
	sqlString.forceSQLString(queryString) ;

	dbQuery query(conn, sqlString,"dbOrderGeneration::load") ;
	dbRow row(conn.getKey()) ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "load SQL = " << queryString) ;
	try
	{
        dbSet set ;
		query.execForSet(set) ;
        ACS_COND_THROW(set.empty(), dbQuery::QueryNoDataFound("empty set")) ; // PRQA S 3081 2
        ACS_COND_THROW(set.size() > 1, exIllegalValueException("Set size > 1")) ;
        set.getNextRow(row) ; // first and only 
	}
	catch (dbQuery::QueryNoDataFound &e)
	{
		*this = tempRecord;  //Nothing found: restore previuos situation.
		return false ;
	}

	loadRow(row, 0) ;

	setFromDatabase() ;

	resetModifiedFlag() ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "load: Dump : \"" << *this) ;

	return true;
}


// update an existing instance in database
dbPersistent::IdType dbOrderGeneration::update(dbConnection &conn)
{
	Lock lock(*this) ;

	if (!getId())
	{
		ObjectNotLoaded ex("dbOrderGeneration::update(). Use the method save() instead.") ; 
		ACS_THROW(ex)
	}

	if (!isFromDatabase())
	{
		ObjectNotLoaded ex("Error: dbOrderGeneration::update(). Use the method save() instead of update().") ; 
		ACS_THROW(ex)
	}

	if (!isModified())
		return 0 ; 

	if(!_processorNameSet) 
	{
		InvalidUse e("Mandatory field \"Processor Name\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_processorVersionSet) 
	{
		InvalidUse e("Mandatory field \"Processor Version\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_processorConfigurationSet) 
	{
		InvalidUse e("Mandatory field \"Processor Configuration\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_algorithmSet) 
	{
		InvalidUse e("Mandatory field \"Algorithm\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_orderTypeSet) 
	{
		InvalidUse e("Mandatory field \"Order Type\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_fileTypeSet) 
	{
		InvalidUse e("Mandatory field \"File Type\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_prioritySet) 
	{
		InvalidUse e("Mandatory field \"Priority\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_troubleShootingSet) 
	{
		InvalidUse e("Mandatory field \"TroubleShooting\" must be set.") ;
		ACS_THROW(e) ;
	}
	if(!_processingTimeWindowSet) 
	{
		InvalidUse e("Mandatory field \"Processing Time Window (Days)\" must be set.") ;
		ACS_THROW(e) ;
	}

    const string &dbKey = conn.getKey() ;
	string queryString ;
	const string dialectName = SQLDialectFactory::dialectName(dbKey);
	if( dialectName == "Informix9" || dialectName == "Postgres8" || dialectName == "Oracle11" ) {
		queryString = string("UPDATE ") + getTable() + " SET " ; 
		queryString += "ProcessorName= " + db::toSQL(dbKey,_processorName) ;
		queryString += ", ProcessorVersion= " + db::toSQL(dbKey,_processorVersion) ;

		queryString += ", ProcessorConfiguration= " + (_processorConfigurationSet ? db::toSQL(dbKey,_processorConfiguration) : string("NULL")) ;
		queryString += ", Algorithm= " + db::toSQL(dbKey,_algorithm) ;
		queryString += ", OrderType= " + db::toSQL(dbKey,_orderType) ;
		queryString += ", FileClass= " + (_fileClassSet ? db::toSQL(dbKey,_fileClass) : string("NULL")) ;
		queryString += ", FileType= " + db::toSQL(dbKey,_fileType) ;
		queryString += ", Active= " + (_activeSet ? db::toSQL(dbKey,_active) : string("NULL")) ;
		queryString += ", Priority= " + db::toSQL(dbKey,_priority) ;
		queryString += ", TroubleShooting= " + db::toSQL(dbKey,_troubleShooting) ;
		queryString += ", ProcessingTimeWindow= " + db::toSQL(dbKey,_processingTimeWindow) ;
		queryString += " WHERE " ;
		queryString += "Id = " + db::toSQL(dbKey,getId()) ;

		ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "Update SQL = " << queryString) ;
	} else {
		ACS_THROW( exIllegalValueException("Unknown db: "+dialectName ));
	}
	SQLString sqlString(dbKey, SQLString::COMMAND) ;
	sqlString.forceSQLString(queryString) ;

	db::Transaction transaction(conn) ;
	transaction.begin_work("dbOrderGeneration_UPDATE") ;

	conn.addStateWrapper(*this) ;
	dbQuery query(conn, sqlString, "dbOrderGeneration::update") ;

    query.execForStatus() ;
	transaction.commit() ;

	resetModifiedFlag() ;
	return getId() ;

}


// remove the class from the database
dbPersistent::IdType dbOrderGeneration::remove(dbConnection &conn)
{
	Lock lock(*this) ;

	if (!getId())
	{
		ACS_THROW(IdNotProvided("Id not set")) ; // PRQA S 3081
	}

    const string &dbKey = conn.getKey() ;
	string queryString ;
	const string dialectName = SQLDialectFactory::dialectName(dbKey);
	if( dialectName == "Informix9" || dialectName == "Postgres8" || dialectName == "Oracle11" ) {
		queryString = "DELETE FROM " + getTable() ;
		queryString += " WHERE " ;
		queryString += "Id = " + string(db::toSQL(dbKey,getId())) ;

	} else {
		ACS_THROW( exIllegalValueException("Unknown db: "+dialectName ));
	}
	SQLString sqlString(dbKey, SQLString::COMMAND) ;
	sqlString.forceSQLString(queryString) ;
	db::Transaction transaction(conn) ;
	transaction.begin_work("dbOrderGeneration_REMOVE") ;

	conn.addStateWrapper(*this) ;
	dbQuery query(conn, sqlString, "dbOrderGeneration::remove") ;

	query.execForStatus() ;
	transaction.commit() ;


	resetFromDatabase() ;
	setModifiedFlag() ;

	return getId() ;
}


// True if the class have valid parameters, false otherwise
bool dbOrderGeneration::validate() const
{
	Lock lock(*this) ;

	return true;
}


// export the class to stream
void dbOrderGeneration::exportObj(rsResourceSet &s) const
{
	Lock lock(*this) ;

	rsPushNSpace nsp(s,"dbOrderGeneration") ;
	dbPersistent::exportObj(s) ;
	s.setValue("_id", getId()) ;
	if(_processorNameSet)
	{
		s.setValue("_processorName",_processorName) ;
	}
	s.setValue("_processorNameSet",_processorNameSet) ;
	if(_processorVersionSet)
	{
		s.setValue("_processorVersion",_processorVersion) ;
	}
	s.setValue("_processorVersionSet",_processorVersionSet) ;
	if(_processorConfigurationSet)
	{
		s.setValue("_processorConfiguration",_processorConfiguration) ;
	}
	s.setValue("_processorConfigurationSet",_processorConfigurationSet) ;
	if(_algorithmSet)
	{
		s.setValue("_algorithm",_algorithm) ;
	}
	s.setValue("_algorithmSet",_algorithmSet) ;
	if(_orderTypeSet)
	{
		s.setValue("_orderType",_orderType) ;
	}
	s.setValue("_orderTypeSet",_orderTypeSet) ;
	if(_fileClassSet)
	{
		s.setValue("_fileClass",_fileClass) ;
	}
	s.setValue("_fileClassSet",_fileClassSet) ;

	if(_fileTypeSet)
	{
		s.setValue("_fileType",_fileType) ;
	}
	s.setValue("_fileTypeSet",_fileTypeSet) ;
	if(_activeSet)
	{
		s.setValue("_active",_active) ;
	}
	s.setValue("_activeSet",_activeSet) ;
	if(_prioritySet)
	{
		s.setValue("_priority",_priority) ;
	}
	s.setValue("_prioritySet",_prioritySet) ;
	if(_troubleShootingSet)
	{
		s.setValue("_troubleShooting",_troubleShooting) ;
	}
	s.setValue("_troubleShootingSet",_troubleShootingSet) ;
	if(_processingTimeWindowSet)
	{
		s.setValue("_processingTimeWindow",_processingTimeWindow) ;
	}
	s.setValue("_processingTimeWindowSet",_processingTimeWindowSet) ;
}


// import the class from a stream
void dbOrderGeneration::importObj(rsResourceSet &s)
{
	Lock lock(*this) ;

	rsPushNSpace nsp(s,"dbOrderGeneration") ;
	dbPersistent::importObj(s) ;
	reset() ;
	unsigned long id ;
	s.getValue("_id", id) ;
	setId(id) ;
	s.getValue("_processorNameSet",_processorNameSet) ;
	if(_processorNameSet)
	{
		s.getValue("_processorName",_processorName) ;
	}
	else
		_processorName = "" ;
	s.getValue("_processorVersionSet",_processorVersionSet) ;
	if(_processorVersionSet)
	{
		s.getValue("_processorVersion",_processorVersion) ;
	}
	else
		_processorVersion = "" ;
	s.getValue("_processorConfigurationSet",_processorConfigurationSet) ;
	if(_processorConfigurationSet)
	{
		s.getValue("_processorConfiguration",_processorConfiguration) ;
	}
	else
		_processorConfiguration = "" ;
	s.getValue("_algorithmSet",_algorithmSet) ;
	if(_algorithmSet)
	{
		s.getValue("_algorithm",_algorithm) ;
	}
	else
		_algorithm = "" ;
	s.getValue("_orderTypeSet",_orderTypeSet) ;
	if(_orderTypeSet)
	{
		s.getValue("_orderType",_orderType) ;
	}
	else
		_orderType = "" ;
	s.getValue("_fileClassSet",_fileClassSet) ;
	if(_fileClassSet)
	{
		s.getValue("_fileClass",_fileClass) ;
	}
	else
		_fileClass = "" ;

	s.getValue("_fileTypeSet",_fileTypeSet) ;
	if(_fileTypeSet)
	{
		s.getValue("_fileType",_fileType) ;
	}
	else
		_fileType = "" ;
	s.getValue("_activeSet",_activeSet) ;
	if(_activeSet)
	{
		s.getValue("_active",_active) ;
	}
	else
		_active = true ;
	s.getValue("_prioritySet",_prioritySet) ;
	if(_prioritySet)
	{
		s.getValue("_priority",_priority) ;
	}
	else
		_priority = 0 ;
	s.getValue("_troubleShootingSet",_troubleShootingSet) ;
	if(_troubleShootingSet)
	{
		s.getValue("_troubleShooting",_troubleShooting) ;
	}
	else
		_troubleShooting = false ;
	s.getValue("_processingTimeWindowSet",_processingTimeWindowSet) ;
	if(_processingTimeWindowSet)
	{
		s.getValue("_processingTimeWindow",_processingTimeWindow) ;
	}
	else
		_processingTimeWindow = 0 ;
}


// export the class to XML stream
void dbOrderGeneration::exportXML(XMLOstream &xst) const
{
	Lock lock(*this) ;

    const string dbKey = ""  ;
	XMLOstream::Tag txml(xst, "dbOrderGeneration");
	dbPersistent::exportXML(xst) ;
	{
		ostringstream os;
		os << getId();
		XMLOstream::Tag txml0(xst, "_id", os.str(), "label=\"Id\"");
	}
	if(_processorNameSet)
	{
		XMLOstream::Tag txml1(xst, "_processorName", _processorName, "label=\"Processor Name\"");
	}
	else
	{
		XMLOstream::Tag txml1(xst, "_processorName", string("<null>"), "label=\"Processor Name\"");
	}
	
	{
		XMLOstream::Tag txml1Set(xst, "_processorNameSet", (_processorNameSet ? "true" : "false")) ;
	}
	if(_processorVersionSet)
	{
		XMLOstream::Tag txml2(xst, "_processorVersion", _processorVersion, "label=\"Processor Version\"");
	}
	else
	{
		XMLOstream::Tag txml2(xst, "_processorVersion", string("<null>"), "label=\"Processor Version\"");
	}
	{
		XMLOstream::Tag txml2Set(xst, "_processorVersionSet", (_processorVersionSet ? "true" : "false")) ;
	}
	if(_processorConfigurationSet)
	{
		XMLOstream::Tag txml3(xst, "_processorConfiguration", _processorConfiguration, "label=\"Processor Configuration\"");
	}
	else
	{
		XMLOstream::Tag txml3(xst, "_processorConfiguration", string("<null>"), "label=\"Processor Configuration\"");
	}
	{
		XMLOstream::Tag txml3Set(xst, "_processorConfigurationSet", (_processorConfigurationSet ? "true" : "false")) ;
	}
	if(_algorithmSet)
	{
		XMLOstream::Tag txml4(xst, "_algorithm", _algorithm, "label=\"Algorithm\"");
	}
	else
	{
		XMLOstream::Tag txml4(xst, "_algorithm", string("<null>"), "label=\"Algorithm\"");
	}
	{
		XMLOstream::Tag txml4Set(xst, "_algorithmSet", (_algorithmSet ? "true" : "false")) ;
	}
	if(_orderTypeSet)
	{
		XMLOstream::Tag txml5(xst, "_orderType", _orderType, "label=\"Order Type\"");
	}
	else
	{
		XMLOstream::Tag txml5(xst, "_orderType", string("<null>"), "label=\"Order Type\"");
	}
	{
		XMLOstream::Tag txml5Set(xst, "_orderTypeSet", (_orderTypeSet ? "true" : "false")) ;
	}
	
	if(_fileClassSet)
	{
		XMLOstream::Tag txml5(xst, "_fileClass", _fileClass, "label=\"File Class\"");
	}
	else
	{
		XMLOstream::Tag txml5(xst, "_fileClass", string("<null>"), "label=\"File Class\"");
	}
	{
		XMLOstream::Tag txml5Set(xst, "_fileClassSet", (_orderTypeSet ? "true" : "false")) ;
	}

	if(_fileTypeSet)
	{
	XMLOstream::Tag txml6(xst, "_fileType", _fileType, "label=\"File Type\"");
	}
	else
	{
	XMLOstream::Tag txml6(xst, "_fileType", string("<null>"), "label=\"File Type\"");
	}
	{
	XMLOstream::Tag txml6Set(xst, "_fileTypeSet", (_fileTypeSet ? "true" : "false")) ;
	}
	if(_activeSet)
	{
	XMLOstream::Tag txml7(xst, "_active", (_active ? "true" : "false"), "label=\"Active\"");
	}
	else
	{
	XMLOstream::Tag txml7(xst, "_active", string("<null>"), "label=\"Active\"");
	}
	{
	XMLOstream::Tag txml7Set(xst, "_activeSet", (_activeSet ? "true" : "false")) ;
	}
	if(_prioritySet)
	{
	XMLOstream::Tag txml8(xst, "_priority", string(db::toSQL(dbKey,_priority)), "label=\"Priority\"");
	}
	else
	{
	XMLOstream::Tag txml8(xst, "_priority", string("<null>"), "label=\"Priority\"");
	}
	{
	XMLOstream::Tag txml8Set(xst, "_prioritySet", (_prioritySet ? "true" : "false")) ;
	}
	if(_troubleShootingSet)
	{
	XMLOstream::Tag txml9(xst, "_troubleShooting", (_troubleShooting ? "true" : "false"), "label=\"TroubleShooting\"");
	}
	else
	{
	XMLOstream::Tag txml9(xst, "_troubleShooting", string("<null>"), "label=\"TroubleShooting\"");
	}
	{
	XMLOstream::Tag txml9Set(xst, "_troubleShootingSet", (_troubleShootingSet ? "true" : "false")) ;
	}
	if(_processingTimeWindowSet)
	{
	XMLOstream::Tag txml10(xst, "_processingTimeWindow", string(db::toSQL(dbKey,_processingTimeWindow)), "label=\"Processing Time Window (Days)\"");
	}
	else
	{
	XMLOstream::Tag txml10(xst, "_processingTimeWindow", string("<null>"), "label=\"Processing Time Window (Days)\"");
	}
	{
	XMLOstream::Tag txml10Set(xst, "_processingTimeWindowSet", (_processingTimeWindowSet ? "true" : "false")) ;
	}
}



// load the object from a row
int dbOrderGeneration::loadRow(const dbRow &row, int offset)
{
	Lock lock(*this) ;

	unsigned long id ;

	row.column(offset + 0, id) ;

	setId(id) ;

	row.columnSet(offset + 1, _processorName, _processorNameSet) ;
	row.columnSet(offset + 2, _processorVersion, _processorVersionSet) ;
	row.columnSet(offset + 3, _processorConfiguration, _processorConfigurationSet) ;
	row.columnSet(offset + 4, _algorithm, _algorithmSet) ;
	row.columnSet(offset + 5, _orderType, _orderTypeSet) ;
	row.columnSet(offset + 6, _fileClass, _fileClassSet) ;
	row.columnSet(offset + 7, _fileType, _fileTypeSet) ;
	row.columnSet(offset + 8, _active, _activeSet) ;
	row.columnSet(offset + 9, _priority, _prioritySet) ;
	row.columnSet(offset + 10, _troubleShooting, _troubleShootingSet) ;
	row.columnSet(offset + 11, _processingTimeWindow, _processingTimeWindowSet) ;


	setFromDatabase() ;

	return offset + 12 ;
}



void dbOrderGeneration::setProcessorName(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 32)
	{
		InvalidUse e("Error: dbOrderGeneration::setProcessorName(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_processorNameSet || _processorName != v ) 
	{
		_processorName = v ;
		_processorNameSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbOrderGeneration::getProcessorName(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _processorNameSet ;
	return _processorName ;
}


void dbOrderGeneration::unsetProcessorName()
{
	Lock lock(*this) ;
	if(_processorNameSet == true)
		setModifiedFlag();
	_processorNameSet = false;
	_processorName = "" ;

}
void dbOrderGeneration::setProcessorVersion(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 8)
	{
		InvalidUse e("Error: dbOrderGeneration::setProcessorVersion(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_processorVersionSet || _processorVersion != v ) 
	{
		_processorVersion = v ;
		_processorVersionSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbOrderGeneration::getProcessorVersion(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _processorVersionSet ;
	return _processorVersion ;
}


void dbOrderGeneration::unsetProcessorVersion()
{
	Lock lock(*this) ;
	if(_processorVersionSet == true)
		setModifiedFlag();
	_processorVersionSet = false;

}
void dbOrderGeneration::setProcessorConfiguration(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 8)
	{
		InvalidUse e("Error: dbOrderGeneration::setProcessorConfiguration(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_processorConfigurationSet || _processorConfiguration != v ) 
	{
		_processorConfiguration = v ;
		_processorConfigurationSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbOrderGeneration::getProcessorConfiguration(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _processorConfigurationSet ;
	return _processorConfiguration ;
}


void dbOrderGeneration::unsetProcessorConfiguration()
{
	Lock lock(*this) ;
	if(_processorConfigurationSet == true)
		setModifiedFlag();
	_processorConfigurationSet = false;

}
void dbOrderGeneration::setAlgorithm(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 32)
	{
		InvalidUse e("Error: dbOrderGeneration::setAlgorithm(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_algorithmSet || _algorithm != v ) 
	{
		_algorithm = v ;
		_algorithmSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbOrderGeneration::getAlgorithm(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _algorithmSet ;
	return _algorithm ;
}


void dbOrderGeneration::unsetAlgorithm()
{
	Lock lock(*this) ;
	if(_algorithmSet == true)
		setModifiedFlag();
	_algorithmSet = false;

}
void dbOrderGeneration::setOrderType(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 8)
	{
		InvalidUse e("Error: dbOrderGeneration::setOrderType(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_orderTypeSet || _orderType != v ) 
	{
		_orderType = v ;
		_orderTypeSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbOrderGeneration::getOrderType(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _orderTypeSet ;
	return _orderType ;
}


void dbOrderGeneration::unsetOrderType()
{
	Lock lock(*this) ;
	if(_orderTypeSet == true)
		setModifiedFlag();
	_orderTypeSet = false;

}

void dbOrderGeneration::setFileClass(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 8)
	{
		InvalidUse e("Error: dbOrderGeneration::setFileClass(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_fileClassSet || _fileClass != v ) 
	{
		_fileClass = v ;
		_fileClassSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbOrderGeneration::getFileClass(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _fileClassSet ;
	return _fileClass ;
}


void dbOrderGeneration::unsetFileClass()
{
	Lock lock(*this) ;
	if(_fileClassSet == true)
		setModifiedFlag();
	_fileClassSet = false;

}


void dbOrderGeneration::setFileType(const string &v)
{
	Lock lock(*this) ;

	if (v.size() > 16)
	{
		InvalidUse e("Error: dbOrderGeneration::setFileType(). String too long.") ;
		ACS_THROW(e) ;
	}

	if (!_fileTypeSet || _fileType != v ) 
	{
		_fileType = v ;
		_fileTypeSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbOrderGeneration::getFileType(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _fileTypeSet ;
	return _fileType ;
}


void dbOrderGeneration::unsetFileType()
{
	Lock lock(*this) ;
	if(_fileTypeSet == true)
		setModifiedFlag();
	_fileTypeSet = false;

}
void dbOrderGeneration::setActive(bool v)
{
	Lock lock(*this) ;

	if (!_activeSet || _active != v ) 
	{
		_active = v ;
		_activeSet = true ;
		setModifiedFlag() ;
	}
}


bool dbOrderGeneration::getActive(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _activeSet ;
	return _active ;
}


void dbOrderGeneration::unsetActive()
{
	Lock lock(*this) ;
	if(_activeSet == true)
		setModifiedFlag();
	_activeSet = false;

}
void dbOrderGeneration::setPriority(int v)
{
	Lock lock(*this) ;

	if (!_prioritySet || _priority != v ) 
	{
		_priority = v ;
		_prioritySet = true ;
		setModifiedFlag() ;
	}
}


int dbOrderGeneration::getPriority(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _prioritySet ;
	return _priority ;
}


void dbOrderGeneration::unsetPriority()
{
	Lock lock(*this) ;
	if(_prioritySet == true)
		setModifiedFlag();
	_prioritySet = false;

}
void dbOrderGeneration::setTroubleShooting(bool v)
{
	Lock lock(*this) ;

	if (!_troubleShootingSet || _troubleShooting != v ) 
	{
		_troubleShooting = v ;
		_troubleShootingSet = true ;
		setModifiedFlag() ;
	}
}


bool dbOrderGeneration::getTroubleShooting(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _troubleShootingSet ;
	return _troubleShooting ;
}


void dbOrderGeneration::unsetTroubleShooting()
{
	Lock lock(*this) ;
	if(_troubleShootingSet == true)
		setModifiedFlag();
	_troubleShootingSet = false;

}
void dbOrderGeneration::setProcessingTimeWindow(int v)
{
	Lock lock(*this) ;

	if (!_processingTimeWindowSet || _processingTimeWindow != v ) 
	{
		_processingTimeWindow = v ;
		_processingTimeWindowSet = true ;
		setModifiedFlag() ;
	}
}


int dbOrderGeneration::getProcessingTimeWindow(bool *set) const
{
	Lock lock(*this) ;

	if (set)
		*set = _processingTimeWindowSet ;
	return _processingTimeWindow ;
}


void dbOrderGeneration::unsetProcessingTimeWindow()
{
	Lock lock(*this) ;
	if(_processingTimeWindowSet == true)
		setModifiedFlag();
	_processingTimeWindowSet = false;

}
// get the field names
string dbOrderGeneration::getFields()
{
	string s ;
	s += getTable() + "." + "Id, ";
	s += getTable() + "." + "ProcessorName, ";
	s += getTable() + "." + "ProcessorVersion, ";
	s += getTable() + "." + "ProcessorConfiguration, ";
	s += getTable() + "." + "Algorithm, ";
	s += getTable() + "." + "OrderType, ";
	s += getTable() + "." + "FileClass, ";
	s += getTable() + "." + "FileType, ";
	s += getTable() + "." + "Active, ";
	s += getTable() + "." + "Priority, ";
	s += getTable() + "." + "TroubleShooting, ";
	s += getTable() + "." + "ProcessingTimeWindow" ;
	return s ;
}


// get the table name
string dbOrderGeneration::getTable()
{
	return "T_OrdersGeneration" ;
}


// get the order by clause
string dbOrderGeneration::getOrderBy()
{
	return "" ;
}


void dbOrderGeneration::writeTo(ostream &o) const
{
	Lock lock(*this) ;
    const string dbKey = "" ;
	o
		 << "_id = " << getId() << "\n" 
		 << "_processorName = " << (_processorNameSet ? _processorName : string("<null>")) << "\n" 
		 << "_processorVersion = " << (_processorVersionSet ? _processorVersion : string("<null>")) << "\n" 
		 << "_processorConfiguration = " << (_processorConfigurationSet ? _processorConfiguration : string("<null>")) << "\n" 
		 << "_algorithm = " << (_algorithmSet ? _algorithm : string("<null>")) << "\n" 
		 << "_orderType = " << (_orderTypeSet ? _orderType : string("<null>")) << "\n" 
		 << "_fileClass = " << (_fileClassSet ? _fileClass : string("<null>")) << "\n" 
		 << "_fileType = " << (_fileTypeSet ? _fileType : string("<null>")) << "\n" 
		 << "_active = " << (_activeSet ? (_active ? "True" : "False") : string("<null>")) << "\n" 
		 << "_priority = " << (_prioritySet ? string(db::toSQL(dbKey,_priority)) : string("<null>")) << "\n" 
		 << "_troubleShooting = " << (_troubleShootingSet ? (_troubleShooting ? "True" : "False") : string("<null>")) << "\n" 
		 << "_processingTimeWindow = " << (_processingTimeWindowSet ? string(db::toSQL(dbKey,_processingTimeWindow)) : string("<null>")) << "\n"  ;
}


void dbOrderGeneration::writeTo(exostream &o) const
{
	Lock lock(*this) ;
    const string dbKey = "" ;
	o
		 << "_id = " << getId() << "\n" 
		 << "_processorName = " << (_processorNameSet ? _processorName : string("<null>")) << "\n" 
		 << "_processorVersion = " << (_processorVersionSet ? _processorVersion : string("<null>")) << "\n" 
		 << "_processorConfiguration = " << (_processorConfigurationSet ? _processorConfiguration : string("<null>")) << "\n" 
		 << "_algorithm = " << (_algorithmSet ? _algorithm : string("<null>")) << "\n" 
		 << "_orderType = " << (_orderTypeSet ? _orderType : string("<null>")) << "\n" 
		 << "_fileClass = " << (_fileClassSet ? _fileClass : string("<null>")) << "\n" 
		 << "_fileType = " << (_fileTypeSet ? _fileType : string("<null>")) << "\n" 
		 << "_active = " << (_activeSet ? (_active ? "True" : "False") : string("<null>")) << "\n" 
		 << "_priority = " << (_prioritySet ? string(db::toSQL(dbKey,_priority)) : string("<null>")) << "\n" 
		 << "_troubleShooting = " << (_troubleShootingSet ? (_troubleShooting ? "True" : "False") : string("<null>")) << "\n" 
		 << "_processingTimeWindow = " << (_processingTimeWindowSet ? string(db::toSQL(dbKey,_processingTimeWindow)) : string("<null>")) << "\n"  ;
}



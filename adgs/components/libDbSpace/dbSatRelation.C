// PRQA S 1050 EOF
/*

	Copyright 1995-2016, Advanced Computer Systems , Inc.
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.acsys.it

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Advanced Computer Systems;
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Advanced Computer Systems, Inc.

	$Prod: A.C.S. Db Space Library $

	$Id$

	$Author$

	$Log$
	Revision 1.31  2016/04/19 13:11:56  marpas
	removing filedName method
	
	Revision 1.30  2016/04/11 13:26:34  marpas
	new db interface adopted
	coding best practices applied
	
	Revision 1.29  2016/03/26 21:44:07  marpas
	using new db I/F
	
	Revision 1.28  2014/05/26 11:41:52  marpas
	dbConv casted to string to avoid problems with new libXMLResources templates
	
	Revision 1.27  2014/02/11 11:03:53  marpas
	refresh method removed - base class is enough
	
	Revision 1.26  2013/03/29 19:51:08  marpas
	removing html related functions
	
	Revision 1.25  2012/11/19 14:16:56  marpas
	HEAD REALIGNEMENT
	
	Revision 1.23  2012/02/13 16:50:12  marpas
	refactoring in progress
	
	Revision 1.22  2011/03/02 18:19:58  marpas
	serial 8 supported on load too
	
	Revision 1.21  2011/03/02 18:00:09  marpas
	serial 8 support
	
	Revision 1.20  2005/06/17 14:09:41  marpas
	std namespace management fixed
	
	Revision 1.19  2005/03/04 21:19:34  marpas
	refresh bug fixed
	
	Revision 1.18  2004/07/13 14:48:06  marpas
	dbPersistent::exDbPersistent is an abstract class
	
	Revision 1.17  2004/07/07 10:30:19  marpas
	dbPersistent I/F changed
	
	Revision 1.16  2004/05/03 14:15:04  marpas
	dbPersistent::remove I/F changed
	
	Revision 1.15  2004/04/13 16:06:57  ivafam
	Corrected error in operator=
	
	Revision 1.14  2004/04/13 15:05:16  marpas
	ace dependencies removed
	dbPersistent::clone method implemented
	dbGeneralQuery::clone method implemented
	XXXQuery::operator= implemented
	
	Revision 1.13  2004/02/04 10:13:22  paoscu
	dbPersistent interface changed.
		

*/

// This file is automatically generated by dbGenerator tool

#include <dbSatRelation.h>
#include <dbQuery.h>
#include <dbRow.h>
#include <dbConv.h>
#include <rsResourceSet.h>
#include <rsPushNSpace.h>
#include <sstream>
#include <XMLOstream.h>

_ACS_BEGIN_NAMESPACE(acs)

using namespace std ;


ACS_CLASS_DEFINE_DEBUG_LEVEL(dbSatRelation)

// constructor
dbSatRelation::dbSatRelation() :
    dbPersistent(),
	_satelliteId(),
	_satelliteIdSet(false),
	_mission(),
	_missionSet(false),
	_sensorId(),
	_sensorIdSet(false)
{
}


// copy constructor
dbSatRelation::dbSatRelation(const dbSatRelation &r):
    dbPersistent(r),
	_satelliteId(r._satelliteId),
	_satelliteIdSet(r._satelliteIdSet),
	_mission(r._mission),
	_missionSet(r._missionSet),
	_sensorId(r._sensorId),
	_sensorIdSet(r._sensorIdSet)
{
}


dbSatRelation::~dbSatRelation() throw() {}


// operator =
dbSatRelation &dbSatRelation::operator=(const dbSatRelation &o)
{
	

	if(this != &o)
	{
		Lock lock(*this); // PRQA S 3050 2
		Lock lock1(o);
		
		dbPersistent::operator=(o) ;
		_satelliteId=o._satelliteId;
		_satelliteIdSet=o._satelliteIdSet;
		_mission=o._mission;
		_missionSet=o._missionSet;
		_sensorId=o._sensorId;
		_sensorIdSet=o._sensorIdSet;
	}
	return *this ;
}

dbPersistent *dbSatRelation::clone() const
{
	return new dbSatRelation(*this) ;
}


string dbSatRelation::className() const
{
	return staticClassName() ;
}


string dbSatRelation::staticClassName()
{
	return "dbSatRelation" ;
}


// initialize the class
void dbSatRelation::reset()
{
	Lock lock(*this);  // PRQA S 3050

	// reset dbPersistent
	dbPersistent::reset() ;
	_satelliteId=0 ;
	_satelliteIdSet=false ;
	_mission=0 ;
	_missionSet=false ;
	_sensorId=0 ;
	_sensorIdSet=false ;
}


// save the data in database
dbPersistent::IdType dbSatRelation::save(dbConnection &conn)
{
	ACS_THROW(InvalidUse("the table doesn't allow save")) ; // PRQA S 3081
}

// load the class from the database. Return true if object exist
bool dbSatRelation::load(dbConnection &conn, IdType id)
{
	ACS_THROW(InvalidUse("the table doesn't allow to load")) ; // PRQA S 3081
}

// update an existing instance in database
dbPersistent::IdType dbSatRelation::update(dbConnection &conn)
{
	ACS_THROW(InvalidUse("the table doesn't allow to update")) ; // PRQA S 3081
}

// remove the class from the database
dbPersistent::IdType dbSatRelation::remove(dbConnection &conn)
{
	ACS_THROW(InvalidUse("the table doesn't allow to remove")) ; // PRQA S 3081
}

// True if the class have valid parameters, false otherwise
bool dbSatRelation::validate() const
{
	return true;
}

// export the class to stream
void dbSatRelation::exportObj(rsResourceSet &s) const
{
	Lock lock(*this); // PRQA S 3050

	rsPushNSpace nsp(s,"dbSatRelation") ;
	dbPersistent::exportObj(s) ;
    RSSetM(s, _satelliteIdSet, _satelliteId) ;
    RSSetM(s, _missionSet, _mission) ;
    RSSetM(s, _sensorIdSet, _sensorId) ;
}


// import the class from a stream
void dbSatRelation::importObj(rsResourceSet &s)
{
	Lock lock(*this); // PRQA S 3050

	rsPushNSpace nsp(s,"dbSatRelation") ;
	dbPersistent::importObj(s) ;
    RSGetM(s, _satelliteIdSet, _satelliteId) ;
    RSGetM(s, _missionSet, _mission) ;
    RSGetM(s, _sensorIdSet, _sensorId) ;
}


// export the class to XML stream
void dbSatRelation::exportXML(XMLOstream &xst) const
{
	Lock lock(*this); // PRQA S 3050
	XMLOstream::Tag txml(xst, "dbSatRelation");
	dbPersistent::exportXML(xst) ;
    XMLTagM(xst, _satelliteIdSet, _satelliteId, "Satellite Id") ;
    XMLTagM(xst, _missionSet, _mission, "Mission") ;
    XMLTagM(xst, _sensorIdSet, _sensorId, "Sensor Id") ;
}




// load the object from a row
int dbSatRelation::loadRow(const dbRow &row, int offset)
{
	Lock lock(*this); // PRQA S 3050

    // PRQA S 3000, 3010 4
	row.columnSet(offset + 0, _satelliteId, _satelliteIdSet) ;
	row.columnSet(offset + 1, _mission, _missionSet) ;
	row.columnSet(offset + 2, _sensorId, _sensorIdSet) ; // PRQA S 4400


	setFromDatabase() ;

	return offset + 3 ; // PRQA S 4400
}



void dbSatRelation::setSatelliteId(int v)
{
	Lock lock(*this); // PRQA S 3050

	if (!_satelliteIdSet || ( _satelliteId != v )) 
	{
		_satelliteId = v ;
		_satelliteIdSet = true ;
		setModifiedFlag() ;
	}
}


int dbSatRelation::getSatelliteId(bool *set) const
{
	Lock lock(*this); // PRQA S 3050

	if (set) { *set = _satelliteIdSet ; }
	return _satelliteId ;
}


void dbSatRelation::unsetSatelliteId()
{
	Lock lock(*this);  // PRQA S 3050
	if(_satelliteIdSet == true) { setModifiedFlag(); }
	_satelliteIdSet = false;

}
void dbSatRelation::setMission(int v)
{
	Lock lock(*this);  // PRQA S 3050

	if (!_missionSet || ( _mission != v ))  
	{
		_mission = v ;
		_missionSet = true ;
		setModifiedFlag() ;
	}
}


int dbSatRelation::getMission(bool *set) const
{
	Lock lock(*this);  // PRQA S 3050

	if (set) { *set = _missionSet ; }
	return _mission ;
}


void dbSatRelation::unsetMission()
{
	Lock lock(*this); // PRQA S 3050
	if(_missionSet == true) {
		setModifiedFlag();
    }
	_missionSet = false;

}
void dbSatRelation::setSensorId(int v)
{
	Lock lock(*this); // PRQA S 3050

	if (!_sensorIdSet || (_sensorId != v ) )
	{
		_sensorId = v ;
		_sensorIdSet = true ;
		setModifiedFlag() ;
	}
}


int dbSatRelation::getSensorId(bool *set) const
{
	Lock lock(*this); // PRQA S 3050

	if (set) {
		*set = _sensorIdSet ;
    }
	return _sensorId ;
}


void dbSatRelation::unsetSensorId()
{
	Lock lock(*this); // PRQA S 3050
	if(_sensorIdSet == true) {
		setModifiedFlag();
    }
	_sensorIdSet = false;

}
// get the field names
string dbSatRelation::getFields()
{
	string s ;
	s += getTable() + "." + "SatelliteId, ";
	s += getTable() + "." + "Mission, ";
	s += getTable() + "." + "SensorId" ;
	return s ;
}


// get the table name
string dbSatRelation::getTable()
{
	return "T_SatRelations" ;
}


// get the order by clause
string dbSatRelation::getOrderBy()
{
	return "" ;
}


void dbSatRelation::writeTo(ostream &o) const
{
	Lock lock(*this);  // PRQA S 3050
    writeToM(o, _satelliteIdSet, _satelliteId) ;
    writeToM(o, _missionSet, _mission) ;
    writeToM(o, _sensorIdSet, _sensorId) ;
}


void dbSatRelation::writeTo(exostream &o) const
{
	Lock lock(*this);  // PRQA S 3050
    writeToM(o, _satelliteIdSet, _satelliteId) ;
    writeToM(o, _missionSet, _mission) ;
    writeToM(o, _sensorIdSet, _sensorId) ;
}


_ACS_END_NAMESPACE

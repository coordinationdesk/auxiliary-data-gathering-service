// PRQA S 1050 EOF
/*

	Copyright 1995-2021, Advanced Computer Systems , Inc.
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.acsys.it

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Advanced Computer Systems;
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Advanced Computer Systems, Inc.

	$Prod: A.C.S. Db Space Library $

	$Id$

	$Author$

	$Log$
	Revision 1.36  2016/04/28 09:29:10  marpas
	code simplified adopting new dbPersistent.h convenience macros
	
	Revision 1.35  2016/04/19 13:11:56  marpas
	removing filedName method
	
	Revision 1.34  2016/04/11 13:26:34  marpas
	new db interface adopted
	coding best practices applied
	
	Revision 1.33  2016/03/26 21:44:07  marpas
	using new db I/F
	
	Revision 1.32  2014/05/26 11:41:52  marpas
	dbConv casted to string to avoid problems with new libXMLResources templates
	
	Revision 1.31  2014/02/11 11:03:53  marpas
	refresh method removed - base class is enough
	
	Revision 1.30  2013/04/12 12:13:06  marpas
	SQLDialectFactory::dialectName() needs a db connection key
	
	Revision 1.29  2013/03/29 19:51:08  marpas
	removing html related functions
	
	Revision 1.28  2012/11/19 14:16:56  marpas
	HEAD REALIGNEMENT
	
	Revision 1.26  2012/02/13 16:50:12  marpas
	refactoring in progress
	
	Revision 1.25  2011/03/02 18:19:58  marpas
	serial 8 supported on load too
	
	Revision 1.24  2011/03/02 18:00:10  marpas
	serial 8 support
	
	Revision 1.23  2010/03/08 11:21:17  enrcar
	EC:: Oracle compatibility added
	
	Revision 1.22  2008/10/07 13:10:51  crivig
	porting to postgres8
	
	Revision 1.21  2005/06/17 14:09:41  marpas
	std namespace management fixed
	
	Revision 1.20  2005/06/08 12:13:41  marpas
	exceptions catching fixed
	
	Revision 1.19  2005/03/04 21:19:34  marpas
	refresh bug fixed
	
	Revision 1.18  2004/07/13 14:48:06  marpas
	dbPersistent::exDbPersistent is an abstract class
	
	Revision 1.17  2004/07/07 10:30:19  marpas
	dbPersistent I/F changed
	
	Revision 1.16  2004/05/03 14:15:04  marpas
	dbPersistent::remove I/F changed
	
	Revision 1.15  2004/04/13 16:06:57  ivafam
	Corrected error in operator=
	
	Revision 1.14  2004/04/13 15:05:16  marpas
	ace dependencies removed
	dbPersistent::clone method implemented
	dbGeneralQuery::clone method implemented
	XXXQuery::operator= implemented
	
	Revision 1.13  2004/02/04 10:13:22  paoscu
	dbPersistent interface changed.
		

*/

// This file is automatically generated by dbGenerator tool

#include <dbSensor.h>
#include <dbQuery.h>
#include <dbRow.h>
#include <dbConv.h>
#include <rsResourceSet.h>
#include <rsPushNSpace.h>
#include <sstream>
#include <XMLOstream.h>
#include <dbSet.h>

_ACS_BEGIN_NAMESPACE(acs)

using namespace std ;


ACS_CLASS_DEFINE_DEBUG_LEVEL(dbSensor)

// constructor
dbSensor::dbSensor() :
    dbPersistent(),
	_sensorId(),
	_sensorIdSet(false),
    _sensorName(),
	_sensorNameSet(false)
{
}


// copy constructor
dbSensor::dbSensor(const dbSensor &r):
    dbPersistent(r),
	_sensorId(r._sensorId),
	_sensorIdSet(r._sensorIdSet),
    _sensorName(r._sensorName),
	_sensorNameSet(r._sensorNameSet)
{
	
}


dbSensor::~dbSensor() throw() {}


// operator =
dbSensor &dbSensor::operator=(const dbSensor &o)
{

	if(this != &o)
	{
		Lock lock(*this); // PRQA S 3050
		Lock lock1(o); // PRQA S 3050
		
		dbPersistent::operator=(o) ;
		_sensorId=o._sensorId;
		_sensorIdSet=o._sensorIdSet;
		_sensorName=o._sensorName;
		_sensorNameSet=o._sensorNameSet;
	}
	return *this ;
}

dbPersistent *dbSensor::clone() const
{
	return new dbSensor(*this) ;
}

string dbSensor::className() const
{
	return staticClassName() ;
}


string dbSensor::staticClassName()
{
	return "dbSensor" ;
}


// initialize the class
void dbSensor::reset()
{
	Lock lock(*this); // PRQA S 3050

	// reset dbPersistent
	dbPersistent::reset() ;
	_sensorId=0 ;
	_sensorIdSet=false ;
	_sensorName="" ;
	_sensorNameSet=false ;
}


// save the data in database
dbPersistent::IdType dbSensor::save(dbConnection &conn) // PRQA S 4020
{
	Lock lock(*this); // PRQA S 3050

	if (!isModified()) { return 0 ; }

	if (isFromDatabase()) 
	{
		ACS_THROW(InvalidUse("Use the method update() instead of save().")) ; // PRQA S 3081 
	}
	if(!_sensorIdSet) 
	{
		ACS_THROW(InvalidUse("Mandatory field \"Sensor Id\" must be set.")) ; // PRQA S 3081
	}
	if(!_sensorNameSet) 
	{
		ACS_THROW(InvalidUse("Mandatory field \"Sensor Name\" must be set.")) ; // PRQA S 3081
	}

    const string &dbKey = conn.getKey() ;
	SQLString queryString( dbKey, SQLString::INSERT ) ;
	queryString.addTableList ( getTable() );
	queryString.addValuesList("SensorId", db::toSQL(dbKey, _sensorId) ) ;
	queryString.addValuesList("SensorName", db::toSQL(dbKey, _sensorName) ) ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "SQL command : " << queryString.getSQL()) ;
	dbQuery query(conn, queryString, "INS " + getTable()) ;	

	if (!query.execForStatus())
	{
		ACS_THROW(dbQuery::QueryExecuteException("Query Execution error: Command : " + queryString.getSQL() + // PRQA S 3081
		                    " Error : " + query.errorString())) ;
	}

	// record that the values come from the database
	setFromDatabase() ; 
	return 0 ;
}


// load the class from the database. Return true if object exist
bool dbSensor::load(dbConnection &conn , IdType id) // PRQA S 4020
{
	Lock lock(*this); // PRQA S 3050

	dbSensor tempRecord(*this); //store current record.


	reset() ; 

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "called")

    const string &dbKey = conn.getKey() ;
	SQLString sqlString ( dbKey, SQLString::SELECT ) ; 
	sqlString.addTableList(getTable()) ;
    sqlString.addSelectList( getFields() );

	//add where
	{
	    dbQueryParameters pp(dbKey);
    	if (tempRecord._sensorIdSet)
		{
	    	pp.addParameter( dbParam(dbKey, getTable(), "SensorId", dbParam::EQUAL_TO, db::toSQL(dbKey, tempRecord._sensorId))); // PRQA S 3050, 3081
    	}  
		else
		{
	    	pp.addParameter( dbParam(dbKey, getTable(), "SensorId", dbParam::ISNULL)); // PRQA S 3050, 3081
		}
	    sqlString.addANDWhereParameter(pp);
	}
	sqlString.setOrderByString(getOrderBy());
 	dbQuery query(conn, sqlString, "Select from "+getTable()) ;

	dbRow row(dbKey) ;
	dbSet setQ ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "SQL = " << sqlString.getSQL()) ;

	query.execForSet(setQ) ;
    if (setQ.size() > 1) // it should not occur
    {
        ACS_THROW(InvalidUse("Unexpected query result dimension: it should return just one row"));
    }
    else
    {
		if ( not setQ.getNextRow(row) )
        {
        	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "No " << getTable() << " record found ");
			*this = tempRecord;  //Nothing found: restore previuos situation.
			return false ;
        }
	}

	loadRow(row, 0) ;

	setFromDatabase() ;

	resetModifiedFlag() ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "Dump : \"" << *this)

	return true;
}


// update an existing instance in database
dbPersistent::IdType dbSensor::update(dbConnection &conn) // PRQA S 4020
{
	Lock lock(*this); // PRQA S 3050

	if (!isFromDatabase())
	{
		ACS_THROW(ObjectNotLoaded("Use the method save() instead of update().")) ;  // PRQA S 3081
	}

	if (!isModified()) { return 0 ; }

    const string &dbKey = conn.getKey() ;
	SQLString sqlString ( dbKey, SQLString::UPDATE ) ;
	sqlString.addTableList(getTable()) ;
   	sqlString.addSetList( "SensorId", db::toSQL( dbKey, _sensorId ) );
   	sqlString.addSetList( "SensorName", db::toSQL( dbKey, _sensorName ) );
	// add where
	{
		dbQueryParameters pp(dbKey);
		if(_sensorIdSet)
		{
	    	pp.addParameter( dbParam(dbKey, getTable(), "SensorId", dbParam::EQUAL_TO, db::toSQL(dbKey, _sensorId))); // PRQA S 3050, 3081
    	} 
		else
		{
	    	pp.addParameter( dbParam(dbKey, getTable(), "SensorId", dbParam::ISNULL)); // PRQA S 3050, 3081
		} 
	    sqlString.addANDWhereParameter(pp);
	}
	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "SQL = " << sqlString.getSQL()) ;

	dbQuery query(conn, sqlString, "Update " + getTable()) ;

	query.execForStatus() ;


	resetModifiedFlag() ;
	return 0 ;

}


// remove the class from the database
dbPersistent::IdType dbSensor::remove(dbConnection &conn)
{
	Lock lock(*this); // PRQA S 3050

    const string &dbKey = conn.getKey() ;

	SQLString sqlString ( dbKey, SQLString::DELETE ) ;
	sqlString.addTableList(getTable()) ;
	// Add where
    {
		dbQueryParameters pp(dbKey) ;
		if (_sensorIdSet)
		{
       		pp.addParameter(dbParam(dbKey, getTable(), "SensorId" , dbParam::EQUAL_TO , db::toSQL(dbKey, _sensorId ))) ;
		}
		else
		{
       		pp.addParameter(dbParam(dbKey, getTable(), "SensorId" , dbParam::ISNULL)) ;
			
		}
		
		sqlString.addANDWhereParameter(pp) ;
	}


	dbQuery query(conn, sqlString, getTable() + " remove") ;

	query.execForStatus() ;

	resetFromDatabase() ;
	setModifiedFlag() ;

	return 0 ;
}


// True if the class have valid parameters, false otherwise
bool dbSensor::validate() const
{
	return true;
}

// export the class to stream
void dbSensor::exportObj(rsResourceSet &s) const
{
	Lock lock(*this); // PRQA S 3050

	rsPushNSpace nsp(s,"dbSensor") ;
	dbPersistent::exportObj(s) ;
    RSSetM(s, _sensorIdSet, _sensorId) ;
    RSSetM(s, _sensorNameSet, _sensorName) ;
}


// import the class from a stream
void dbSensor::importObj(rsResourceSet &s)
{
	Lock lock(*this); // PRQA S 3050

	rsPushNSpace nsp(s,"dbSensor") ;
	dbPersistent::importObj(s) ;
    RSGetM(s, _sensorIdSet, _sensorId) ;
    RSGetM(s, _sensorNameSet, _sensorName) ;
}


// export the class to XML stream
void dbSensor::exportXML(XMLOstream &xst) const
{
	Lock lock(*this); // PRQA S 3050
	XMLOstream::Tag txml(xst, "dbSensor");
	dbPersistent::exportXML(xst) ;
    XMLTagM(xst, _sensorIdSet, _sensorId, "Sensor Id") ;
    XMLTagM(xst, _sensorNameSet, _sensorName, "Sensor Name") ;
}



// load the object from a row
int dbSensor::loadRow(const dbRow &row, int offset)
{
	Lock lock(*this); // PRQA S 3050

    // PRQA S 3000, 3010 3
	row.columnSet(offset + 0, _sensorId, _sensorIdSet) ;
	row.columnSet(offset + 1, _sensorName, _sensorNameSet) ;


	setFromDatabase() ;

	return offset + 2 ; // PRQA S 4400
}


void dbSensor::setSensorId(int v)
{
	Lock lock(*this); // PRQA S 3050

	if (isFromDatabase())
	{
		ACS_THROW(InvalidUse("Primary Key is from Database.")) ; // PRQA S 3081
	}

	if (!_sensorIdSet || (_sensorId != v ) )
	{
		_sensorId = v ;
		_sensorIdSet = true ;
		setModifiedFlag() ;
	}
}


int dbSensor::getSensorId(bool *set) const
{
	Lock lock(*this); // PRQA S 3050

	if (set) { *set = _sensorIdSet ; }
	return _sensorId ;
}


void dbSensor::unsetSensorId()
{
	if (isFromDatabase())
	{
		ACS_THROW(InvalidUse("Primary Key is from Database.")) ; // PRQA S 3081
	}

	Lock lock(*this); // PRQA S 3050
	if(_sensorIdSet == true) {
		setModifiedFlag();
    }
	_sensorIdSet = false;

}
void dbSensor::setSensorName(const string &v)
{
	Lock lock(*this); // PRQA S 3050

	if (v.size() > 64) // PRQA S 4400
	{
		ACS_THROW(InvalidUse("String too long.")) ; // PRQA S 3081
	}

	if (!_sensorNameSet || _sensorName != v ) 
	{
		_sensorName = v ;
		_sensorNameSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbSensor::getSensorName(bool *set) const
{
	Lock lock(*this); // PRQA S 3050

	if (set) { *set = _sensorNameSet ; }
	return _sensorName ;
}


void dbSensor::unsetSensorName()
{
	Lock lock(*this); // PRQA S 3050
	if(_sensorNameSet == true) {
		setModifiedFlag();
    }
	_sensorNameSet = false;

}
// get the field names
string dbSensor::getFields()
{
	string s ;
	s += getTable() + "." + "SensorId, ";
	s += getTable() + "." + "SensorName" ;
	return s ;
}


// get the table name
string dbSensor::getTable()
{
	return "T_Sensors" ;
}


// get the order by clause
string dbSensor::getOrderBy()
{
	return "" ;
}


void dbSensor::writeTo(ostream &o) const
{
	Lock lock(*this); // PRQA S 3050
    writeToM(o, _sensorIdSet, _sensorId) ;
    writeToM(o, _sensorNameSet, _sensorName) ;
}


void dbSensor::writeTo(exostream &o) const
{
	Lock lock(*this); // PRQA S 3050
    writeToM(o, _sensorIdSet, _sensorId) ;
    writeToM(o, _sensorNameSet, _sensorName) ;
}


_ACS_END_NAMESPACE //acs

// PRQA S 1050 EOF
/*

	Copyright 1995-20121, Advanced Computer Systems , Inc.
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.acsys.it

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Advanced Computer Systems;
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Advanced Computer Systems, Inc.

	$Prod: A.C.S. Db Space Library $

	$Id$

	$Author$

	$Log$
	Revision 1.36  2016/04/28 09:29:10  marpas
	code simplified adopting new dbPersistent.h convenience macros
	
	Revision 1.35  2016/04/19 13:11:56  marpas
	removing filedName method
	
	Revision 1.34  2016/04/11 13:26:34  marpas
	new db interface adopted
	coding best practices applied
	
	Revision 1.33  2016/03/26 21:44:07  marpas
	using new db I/F
	
	Revision 1.32  2014/05/26 11:41:52  marpas
	dbConv casted to string to avoid problems with new libXMLResources templates
	
	Revision 1.31  2014/02/11 11:03:53  marpas
	refresh method removed - base class is enough
	
	Revision 1.30  2013/04/12 12:13:06  marpas
	SQLDialectFactory::dialectName() needs a db connection key
	
	Revision 1.29  2013/03/29 19:51:09  marpas
	removing html related functions
	
	Revision 1.28  2012/11/19 14:16:56  marpas
	HEAD REALIGNEMENT
	
	Revision 1.26  2012/02/13 16:50:12  marpas
	refactoring in progress
	
	Revision 1.25  2011/03/02 18:19:58  marpas
	serial 8 supported on load too
	
	Revision 1.24  2011/03/02 18:00:10  marpas
	serial 8 support
	
	Revision 1.23  2010/03/08 11:21:17  enrcar
	EC:: Oracle compatibility added
	
	Revision 1.22  2008/10/07 13:10:51  crivig
	porting to postgres8
	
	Revision 1.21  2005/06/17 14:09:41  marpas
	std namespace management fixed
	
	Revision 1.20  2005/06/08 12:13:41  marpas
	exceptions catching fixed
	
	Revision 1.19  2005/03/04 21:19:34  marpas
	refresh bug fixed
	
	Revision 1.18  2004/07/13 14:48:06  marpas
	dbPersistent::exDbPersistent is an abstract class
	
	Revision 1.17  2004/07/07 10:30:19  marpas
	dbPersistent I/F changed
	
	Revision 1.16  2004/05/03 14:15:04  marpas
	dbPersistent::remove I/F changed
	
	Revision 1.15  2004/04/13 16:06:57  ivafam
	Corrected error in operator=
	
	Revision 1.14  2004/04/13 15:05:16  marpas
	ace dependencies removed
	dbPersistent::clone method implemented
	dbGeneralQuery::clone method implemented
	XXXQuery::operator= implemented
	
	Revision 1.13  2004/02/04 10:13:22  paoscu
	dbPersistent interface changed.
		

*/

// This file is automatically generated by dbGenerator tool

#include <dbStation.h>
#include <dbQuery.h>
#include <dbRow.h>
#include <dbConv.h>
#include <dbSet.h>
#include <rsResourceSet.h>
#include <rsPushNSpace.h>
#include <sstream>
#include <XMLOstream.h>

_ACS_BEGIN_NAMESPACE(acs)

using namespace std ;


ACS_CLASS_DEFINE_DEBUG_LEVEL(dbStation)

// constructor
dbStation::dbStation() :
    dbPersistent(),
	_stationId(),
	_stationIdSet(false),
    _stationName(),
	_stationNameSet(false),
    _stationAcronym(),
	_stationAcronymSet(false)
{
}


// copy constructor
dbStation::dbStation(const dbStation &r):
    dbPersistent(r),
	_stationId(r._stationId),
	_stationIdSet(r._stationIdSet),
    _stationName(r._stationName),
	_stationNameSet(r._stationNameSet),
    _stationAcronym(r._stationAcronym),
	_stationAcronymSet(r._stationAcronymSet)
{
}


dbStation::~dbStation() throw() {}


// operator =
dbStation &dbStation::operator=(const dbStation &o)
{
	

	if(this != &o)
	{	
		Lock lock(*this); // PRQA S 3050 2
		Lock lock1(o);
		
		dbPersistent::operator=(o) ;
		_stationId=o._stationId;
		_stationIdSet=o._stationIdSet;
		_stationName=o._stationName;
		_stationNameSet=o._stationNameSet;
		_stationAcronym=o._stationAcronym;
		_stationAcronymSet=o._stationAcronymSet;
	}
	return *this ;
}

dbPersistent *dbStation::clone() const
{
	return new dbStation(*this) ;
}
	

string dbStation::className() const
{
	return staticClassName() ;
}


string dbStation::staticClassName()
{
	return "dbStation" ;
}


// initialize the class
void dbStation::reset()
{
	Lock lock(*this); // PRQA S 3050 

	// reset dbPersistent
	dbPersistent::reset() ;
	_stationId=0 ;
	_stationIdSet=false ;
	_stationName="" ;
	_stationNameSet=false ;
	_stationAcronym="" ;
	_stationAcronymSet=false ;
}


// save the data in database
dbPersistent::IdType dbStation::save(dbConnection &conn) // PRQA S 4020
{
	Lock lock(*this); // PRQA S 3050 

	if (!isModified()) { return 0 ; }

	if (isFromDatabase()) 
	{
		ACS_THROW(InvalidUse("Use the method update() instead of save().")) ; // PRQA S 3081
	}
	if(!_stationIdSet) 
	{
		ACS_THROW(InvalidUse("Mandatory field \"Station Id\" must be set.")) ; // PRQA S 3081
	}
	if(!_stationNameSet) 
	{
		ACS_THROW(InvalidUse("Mandatory field \"Station Name\" must be set.")) ; // PRQA S 3081
	}
	if(!_stationAcronymSet) 
	{
		ACS_THROW(InvalidUse("Mandatory field \"Station Acronym\" must be set.")) ; // PRQA S 3081
	}
  
	const string &dbKey = conn.getKey() ;
	SQLString queryString( dbKey, SQLString::INSERT ) ;
	queryString.addTableList ( getTable() );
	queryString.addValuesList("StationId", db::toSQL(dbKey, _stationId) ) ;
	queryString.addValuesList("StationName", db::toSQL(dbKey, _stationName) ) ;
	queryString.addValuesList("StationAcronym", db::toSQL(dbKey, _stationAcronym) ) ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "SQL command : " << queryString.getSQL()) ;
	dbQuery query(conn, queryString, "INS " + getTable()) ;	

	if (!query.execForStatus())
	{
		ACS_THROW(dbQuery::QueryExecuteException("Query Execution error: Command : " + queryString.getSQL() + // PRQA S 3081
		    " Error : " + query.errorString())) ;
	}

	// record that the values come from the database
	setFromDatabase() ; 
	return 0 ;
}


// load the class from the database. Return true if object exist
bool dbStation::load(dbConnection &conn , IdType id) // PRQA S 4020
{
	Lock lock(*this); // PRQA S 3050 

	dbStation tempRecord(*this); //store current record.


	reset() ; 

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "called") ;

	const string &dbKey = conn.getKey() ;
	SQLString sqlString ( dbKey, SQLString::SELECT ) ; 
	sqlString.addTableList(getTable()) ;
    sqlString.addSelectList( getFields() );

	//add where
	{
	    dbQueryParameters pp(dbKey);
    	if (tempRecord._stationIdSet)
		{
	    	pp.addParameter( dbParam(dbKey, getTable(), "StationId", dbParam::EQUAL_TO, db::toSQL(dbKey, tempRecord._stationId))); // PRQA S 3050, 3081
    	}  
		else
		{
	    	pp.addParameter( dbParam(dbKey, getTable(), "StationId", dbParam::ISNULL)); // PRQA S 3050, 3081
		}
	    sqlString.addANDWhereParameter(pp);
	}
	sqlString.setOrderByString(getOrderBy());
 	dbQuery query(conn, sqlString, "Select StationId") ;
	dbRow row(dbKey) ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "SQL = " << sqlString.getSQL()) ;

	dbSet setQ ;
	query.execForSet(setQ) ;
    if (setQ.size() > 1) // it should not occur
    {
        ACS_THROW(InvalidUse("Unexpected query result dimension: it should return just one row"));
    }
    else
    {
		if ( not setQ.getNextRow(row) )
        {
        	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "No " << getTable() << " record found ");
			*this = tempRecord;  //Nothing found: restore previuos situation.
			return false ;
        }
	}
	loadRow(row, 0) ;

	setFromDatabase() ;

	resetModifiedFlag() ;

	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "Dump : \"" << *this ) ;

	return true;
}


// update an existing instance in database
dbPersistent::IdType dbStation::update(dbConnection &conn) // PRQA S 4020
{
	Lock lock(*this); // PRQA S 3050 

	if (!isFromDatabase())
	{
		ACS_THROW(ObjectNotLoaded("Use the method save() instead of update().")) ;  // PRQA S 3081
	}

	if (!isModified()) { return 0 ;  }

    const string &dbKey = conn.getKey() ;
	SQLString sqlString ( dbKey, SQLString::UPDATE ) ;
	sqlString.addTableList(getTable()) ;
   	sqlString.addSetList( "StationId", db::toSQL( dbKey, _stationId ) );
   	sqlString.addSetList( "StationName", db::toSQL( dbKey, _stationName ) );
   	sqlString.addSetList( "StationAcronym", db::toSQL( dbKey, _stationAcronym ) );
	// add where
	{
		dbQueryParameters pp(dbKey);
		if(_stationIdSet)
		{
	    	pp.addParameter( dbParam(dbKey, getTable(), "StationId", dbParam::EQUAL_TO, db::toSQL(dbKey, _stationId))); // PRQA S 3050, 3081
    	} 
		else
		{
	    	pp.addParameter( dbParam(dbKey, getTable(), "StationId", dbParam::ISNULL)); // PRQA S 3050, 3081
		} 
	    sqlString.addANDWhereParameter(pp);
	}
	ACS_CLASS_WRITE_DEBUG(ACS_VLO_VERB, "SQL = " << sqlString.getSQL()) ;

	dbQuery query(conn, sqlString, "Update " + getTable()) ;

	query.execForStatus() ;


	resetModifiedFlag() ;
	return 0 ;

}


// remove the class from the database
dbPersistent::IdType dbStation::remove(dbConnection &conn)
{
	Lock lock(*this); // PRQA S 3050 

    const string &dbKey = conn.getKey() ;
	SQLString sqlString ( dbKey, SQLString::DELETE ) ;
	sqlString.addTableList(getTable()) ;
	// Add where
    {
		dbQueryParameters pp(dbKey) ;
		if (_stationIdSet)
		{
       		pp.addParameter(dbParam(dbKey, getTable(), "StationId" , dbParam::EQUAL_TO , db::toSQL(dbKey, _stationId ))) ;
		}
		else
		{
       		pp.addParameter(dbParam(dbKey, getTable(), "StationId" , dbParam::ISNULL)) ;
			
		}
		
		sqlString.addANDWhereParameter(pp) ;
	}


	dbQuery query(conn, sqlString, getTable() + " remove") ;

	query.execForStatus() ;

	resetFromDatabase() ;
	setModifiedFlag() ;

	return 0 ;
}


// True if the class have valid parameters, false otherwise
bool dbStation::validate() const
{
	return true;
}

// export the class to stream
void dbStation::exportObj(rsResourceSet &s) const
{
	Lock lock(*this); // PRQA S 3050 

	rsPushNSpace nsp(s,"dbStation") ;
	dbPersistent::exportObj(s) ;
    RSSetM(s, _stationIdSet, _stationId) ;
    RSSetM(s, _stationNameSet, _stationName) ;
    RSSetM(s, _stationAcronymSet, _stationAcronym) ;
}


// import the class from a stream
void dbStation::importObj(rsResourceSet &s)
{
	Lock lock(*this); // PRQA S 3050 

	rsPushNSpace nsp(s,"dbStation") ;
	dbPersistent::importObj(s) ;
    RSGetM(s, _stationIdSet, _stationId) ;
    RSGetM(s, _stationNameSet, _stationName) ;
    RSGetM(s, _stationAcronymSet, _stationAcronym) ;
}


// export the class to XML stream
void dbStation::exportXML(XMLOstream &xst) const
{
	Lock lock(*this); // PRQA S 3050 
	XMLOstream::Tag txml(xst, "dbStation");
	dbPersistent::exportXML(xst) ;
    XMLTagM(xst, _stationIdSet, _stationId, "Station Id") ;
    XMLTagM(xst, _stationNameSet, _stationName, "Station Name") ;
    XMLTagM(xst, _stationAcronymSet, _stationAcronym, "Station Acronym") ;
}




// load the object from a row
int dbStation::loadRow(const dbRow &row, int offset)
{
	Lock lock(*this); // PRQA S 3050 

    // PRQA S 3000, 3010 4
	row.columnSet(offset + 0, _stationId, _stationIdSet) ;
	row.columnSet(offset + 1, _stationName, _stationNameSet) ;
	row.columnSet(offset + 2, _stationAcronym, _stationAcronymSet) ; // PRQA S 4400


	setFromDatabase() ;

	return offset + 3 ;// PRQA S 4400
}



void dbStation::setStationId(int v)
{
	Lock lock(*this); // PRQA S 3050 

	if (isFromDatabase())
	{
		ACS_THROW(InvalidUse("Primary Key is from Database.")) ;  // PRQA S 3081
	}

	if (!_stationIdSet || (_stationId != v ) )
	{
		_stationId = v ;
		_stationIdSet = true ;
		setModifiedFlag() ;
	}
}


int dbStation::getStationId(bool *set) const
{
	Lock lock(*this); // PRQA S 3050 

	if (set) { *set = _stationIdSet ; }
	return _stationId ;
}


void dbStation::unsetStationId()
{
	if (isFromDatabase())
	{
		ACS_THROW(InvalidUse("Primary Key is from Database.")) ;  // PRQA S 3081
	}

	Lock lock(*this); // PRQA S 3050
	if(_stationIdSet == true) {
		setModifiedFlag();
    }
	_stationIdSet = false;

}
void dbStation::setStationName(const string &v)
{
	Lock lock(*this); // PRQA S 3050 

	if (v.size() > 64) // PRQA S 4400
	{
		ACS_THROW(InvalidUse("String too long.")) ; // PRQA S 3081
	}

	if (!_stationNameSet || ( _stationName != v ) )
	{
		_stationName = v ;
		_stationNameSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbStation::getStationName(bool *set) const
{
	Lock lock(*this); // PRQA S 3050 

	if (set) {
		*set = _stationNameSet ;
    }
	return _stationName ;
}


void dbStation::unsetStationName()
{
	Lock lock(*this); // PRQA S 3050 
	if(_stationNameSet == true) {
		setModifiedFlag();
    }
	_stationNameSet = false;

}
void dbStation::setStationAcronym(const string &v)
{
	Lock lock(*this); // PRQA S 3050 

	if (v.size() > 4) // PRQA S 4400
	{
		ACS_THROW(InvalidUse("String too long.")) ; // PRQA S 3081
	}

	if (!_stationAcronymSet || (_stationAcronym != v )  )
	{
		_stationAcronym = v ;
		_stationAcronymSet = true ;
		setModifiedFlag() ;
	}
}


const string &dbStation::getStationAcronym(bool *set) const
{
	Lock lock(*this); // PRQA S 3050 

	if (set) {
		*set = _stationAcronymSet ;
    }
	return _stationAcronym ;
}


void dbStation::unsetStationAcronym()
{
	Lock lock(*this); // PRQA S 3050 
	if(_stationAcronymSet == true) {
		setModifiedFlag();
    }
	_stationAcronymSet = false;

}
// get the field names
string dbStation::getFields()
{
	string s ;
	s += getTable() + "." + "StationId, ";
	s += getTable() + "." + "StationName, ";
	s += getTable() + "." + "StationAcronym" ;
	return s ;
}


// get the table name
string dbStation::getTable()
{
	return "T_Stations" ;
}


// get the order by clause
string dbStation::getOrderBy()
{
	return "" ;
}


void dbStation::writeTo(ostream &o) const
{
	Lock lock(*this); // PRQA S 3050 
    writeToM(o, _stationIdSet, _stationId) ;
    writeToM(o, _stationNameSet, _stationName) ;
    writeToM(o, _stationAcronymSet, _stationAcronym) ;
}


void dbStation::writeTo(exostream &o) const
{
	Lock lock(*this); // PRQA S 3050 
    writeToM(o, _stationIdSet, _stationId) ;
    writeToM(o, _stationNameSet, _stationName) ;
    writeToM(o, _stationAcronymSet, _stationAcronym) ;
}


_ACS_END_NAMESPACE

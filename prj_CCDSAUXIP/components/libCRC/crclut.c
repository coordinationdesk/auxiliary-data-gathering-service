/*
    Copyright 1995-2022, Exprivia SpA - DFDA-AS
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.exprivia.com

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Exprivia SpA
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Exprivia SpA
*/
/* 
 *         $Prod: A.C.S. CRC *LUT* Decoder crclut.C $
 * 
 *         $Id$
 * 
 *         $Author$
 * 
 *         $Log$
 *         Revision 2.2  2008/07/03 16:39:38  enrcar
 *         EC:: uint32_t is used instead of ulong
 *
 *         Revision 2.1  2006/10/04 15:54:27  enrcar
 *         global path used for includes
 *
 *         Revision 2.0  2006/02/28 08:31:43  marpas
 *         Exception 2.1 I/F adopted
 *
 *         Revision 1.2  2004/12/02 18:53:52  enrcar
 *         header modified
 *
 *         Revision 1.1  2003/07/18 14:58:53  enrcar
 *         renamed - was crclut.C
 * 
 *         Revision 1.7  2003/07/18 09:04:11  enrcar
 *         Changed for tag warnings
 * 
 *         Revision 1.6  2002/12/03 14:42:32  enrcar
 *         changed crc_lutcheck and crc_lutdecode arguments in order to avoid a typedef
 * 
 *         Revision 1.5  2002/12/03 14:24:58  enrcar
 *         Added a const in both crc_lutdecode() and crc_lutcheck() argument
 * 
 *         Revision 1.4  2002/11/12 08:29:46  enrcar
 *         Added a C++ like costructor/destructor
 * 
 *         Revision 1.3  2002/11/11 17:44:31  enrcar
 *         Tags rewritten
 * 
 *   
 */
   


#include <crcmodel.h>
#include <crclut.h>


/******************************************************************************/
/* The LUT table is generated by data structure                               */
/* RUN THIS AFTER SETUP, AND BEFORE ANY OTHER CALL                            */
/******************************************************************************/
void crc_lutgentable(crcmodel* p_cm )	/* data structure */
{
	for (int i=0; i<256; i++)
    {
         p_cm->ptable[i]=cm_tab(p_cm,i);
    }
    
    return ;
}


/******************************************************************************/
/* CRC is calculated from input data.                                         */
/* Use crc_lutget(.) to extract the CRC value                                 */
/* Use crc_lutcheck(.) to compare the CRC with the expected value             */
/* See also crc_lutbyte(.)                                                    */
/******************************************************************************/
void crc_lutdecode(	crcmodel* p_cm,		/* data structure */
					const unsigned char* blk_adrIN,	/* first input byte address */
                    uint32_t  blk_len)		/* No. of bytes to process */
{

	const unsigned char* blk_adr = blk_adrIN ;

	if (p_cm->cm_refin==TRUE)
    {
        while (blk_len--)
            p_cm->cm_reg = p_cm->ptable[(p_cm->cm_reg ^ *blk_adr++) & 0xFFL] ^ (p_cm->cm_reg >> 8) ;
    }
    else
    {
		if (p_cm->cm_width==16)
		{ 
            while (blk_len--)
                p_cm->cm_reg = p_cm->ptable[((p_cm->cm_reg>>8) ^ *blk_adr++) & 0x00FFL] ^ ((p_cm->cm_reg << 8)&0xFF00L);
        }
        else 
            if (p_cm->cm_width==32)
            { 
                while (blk_len--)
                    p_cm->cm_reg = p_cm->ptable[((p_cm->cm_reg>>24) ^ *blk_adr++) & 0xFFL] ^ (p_cm->cm_reg << 8) ;
            }	
		;	/* end if */
    }	/* end if */

	return ;
}


/******************************************************************************/
/* CRC is calculated from a single-byte input data.                           */
/* Use crc_lutget(.) to extract the CRC value                                 */
/* Use crc_lutcheck(.) to compare the CRC with the expected value             */
/* See also crc_lutdecode(.)                                                  */
/******************************************************************************/
void crc_lutbyte(crcmodel* p_cm, int ch)
{
	unsigned char c;
    c=(unsigned char) ch;
    crc_lutdecode(p_cm, &c, 1) ;
	return ;
}


/******************************************************************************/
/* Extract CRC value                                                          */
/* YOU MUST RUN crc_lutdecode() *BEFORE* getting this value!!!!!!!!!          */
/******************************************************************************/
uint32_t crc_lutget(const crcmodel* p_cm)
{
    return (p_cm->cm_xorot ^ p_cm->cm_reg) ;
}


/******************************************************************************/
/* CRC is calculated and compared with the expected value                     */
/* Output value is 0 if CRC==CRCexpected, -1 otherwise                        */
/*                                                                            */
/* The expected value must be placed at the end of input data                 */
/* If WIDTH is <=16, the expected value must be placed on following 2 bytes   */
/* Otherwise, if WIDTH is >17, the expected value must be placed on ..        */
/*  ..following 4 bytes.                                                      */
/*                                                                            */
/* Example: Message 0x 00 11 22 33 (4 bytes)                                  */
/* #1 Coded with CRC-16: 0x9627                                               */
/* #2 Coded with CRC-32: 0x24c2316d                                           */
/* The buffer should be:                                                      */
/*                                                                            */
/*        #1    #2                                                            */
/*   0    00    00                                                            */
/*   1    11    11                                                            */
/*   2    22    22                                                            */
/*   3    33    33                                                            */
/*   4    96    24                                                            */
/*   5    27    c2                                                            */
/*   6     -    31                                                            */
/*   7     -    6d                                                            */
/*                                                                            */
/*!!!!!!!!!!  DO NOT USE 0x00009627 for CRC-16, or it won't work  !!!!!!!!!!!!*/
/*                                                                            */
/******************************************************************************/
int 									/* OUTPUT value:  0:NO ERRORS, -1:ERRORS */
	crc_lutcheck(	crcmodel* p_cm,		/* data structure */
					const unsigned char* blk_adr,	/* first input byte address */
                    uint32_t  blk_len)		/* No. of bytes to process */
{
	int diff ;
    uint32_t crc1 ;
    uint32_t crc2 ;
	crc_lutdecode( p_cm, blk_adr, blk_len ) ;
    crc1=crc_lutget(p_cm);
   
    if (p_cm->cm_width<=16)
    {
        crc2=( ( blk_adr[blk_len] << 8 | blk_adr[blk_len+1] ) & 0xFFFF ) ;
        diff=( ( (crc1&0xFFFF)==crc2)? 0 : -1 ) ; 
	}
    else
    {
     	crc2=( blk_adr[blk_len] << 24 | blk_adr[blk_len+1] << 16 | blk_adr[blk_len+2] << 8 | blk_adr[blk_len+3] ) ;
        diff=( (crc1==crc2)? 0 : -1 ) ; 
    }
    
    return diff ;
}


// PRQA S 1050 EOF
/*

	Copyright 1995-2022 Exprivia, SPA - DFDA-AS
	Via Della Bufalotta, 378 - 00139 Roma - Italy
	http://www.acsys.it

	All Rights Reserved.

	This is UNPUBLISHED PROPRIETARY SOURCE CODE of Exprivia SpA
	the contents of this file may not be disclosed to third parties, copied or
	duplicated in any form, in whole or in part, without the prior written
	permission of Exprivia SpA.

*/

#ifndef _StopController_H_
#define _StopController_H_

#include <acs_c++config.hpp>
#include <Singleton.hpp>
#include <exException.h>
#include <exStream.h>
#include <ThreadSafe.h>

#include <sys/time.h> // PRQA S 1013
#include <set>

_ACS_BEGIN_NAMESPACE(acs)

/**
 * \brief Manages the stop requests to a thread
 * It is the container of the stop requests
 * It derives from virtual base class ThreadSafe: it is harmless 
 **/

class StopController { 

public:

	/** StopController Exceptions */
	exDECLARE_EXCEPTION(StopControllerException, exException) ; // PRQA S 2131, 2502

    /**
       * \brief It is the "strength" of the halt request 
	   *
	   * The following relation MUST be always true: NONE < LAZY < IMMEDIATE
       **/
	enum HaltLevel { // NOSONAR - enum is enough 
		NONE=1,
		LAZY=2,
		IMMEDIATE=3
	} ;



	/**
	   * When created the halt level is set to NONE
	   **/
	StopController() = default ;

	virtual ~StopController() = default ;

	/**
	 * Does not copy the halt level: new StopController will be created with halt level to NONE
	 **/
	StopController(const StopController & );

	/**
	 * Does not copy the halt level: the halt level is left unchanged
	 **/
	StopController &operator=(const StopController &);

	virtual HaltLevel getHaltLevel() const ;

	/**
	   * The halt level is changed only if the new level is higher than current one.
	   * i.e. only the following transitions are performed
	   * NONE -> LAZY
	   * NONE -> IMMEDIATE
	   * LAZY -> IMMEDIATE
	   * In case of illegal transition the halt value is silently left unchanged.
	   **/
	virtual void setHaltLevel(HaltLevel) ;

	/**
	 *\brief Returns true if halt has been requested.
	 * it returns true if the halt level is LAZY or IMMEDIATE
	 */
	virtual bool requestedCancel() const ;
    
	/**
	   * Wait for the timeout or cancel. Returns true if cancel was requested, false if timeout expired
	   *
	   * \param msec the timeout.
	   */
	virtual bool timeoutOrCancel(size_t msec) const ; // PRQA S 2624, 4400, 4405

    bool haltImmediate() const noexcept ;
    bool haltLazy() const noexcept ;

    static unsigned long nanosleep(unsigned long nanosec) ; // PRQA S 2502

	/**
	   * Obtain a "Condition" (as shared pointer), directly forged by the StopController.
	   * The rationale is that the user's application might need a Condition for its own use
	   * (typically, waiting for an event) and would like to link the Condition to the StopController:
	   * The result is that, if a stop is triggered, the custom Condition will receive a broadcast.
	   * Thus immediately interrupting the wait on the Condition .
	   * Each Condition generated by this method is internally stored in a set.
	   * To remove one Condition from the set, /see unregister_condition
	   */
	std::shared_ptr<Condition> create_condition() const ; 
	
	/**
	  * Unregister a user's Condition, obtained by method: /see create_condition()
	  * After the Unregister, the Condition is removed from the set (so, one occurence of the shared pointer is released)
	  * and it will receive no further broadcasts in case of stop.
	  * Returns true in case of successful erase.
	*/
	bool unregister_condition(const std::shared_ptr<Condition>& p) const ; 

#ifndef TEST
protected:
#else
public:
#endif
	virtual void reset() ;

	/**
	   * \brief Yield to other thread (possibly)
	   */
	static void yield() noexcept ; 

private:
	Condition _condition = {} ;
	ThreadSafe _mutex = {} ;
	mutable std::set < std::shared_ptr<Condition> > _ext_conditions_S = {} ;
	HaltLevel volatile _haltLevel = NONE ; // NOSONAR - volatile because can be modified asynchronously from other cores

	ACS_CLASS_DECLARE_DEBUG_LEVEL(StopController) ;

};

std::ostream &operator << (std::ostream &, const StopController::HaltLevel &) ;
exostream &operator << (exostream &, const StopController::HaltLevel &) ; // PRQA S 2072

std::ostream &operator << (std::ostream &, const StopController &) ;
exostream &operator << (exostream &, const StopController &) ; // PRQA S 2072


/**
 * \brief Application Stop Controller Singleton
 * Implements a unique and global scope accessible StopController 
 * via a Singleton < StopController >
 **/
class AppStopControllerSingleton : public pattern::Singleton < StopController >  // PRQA S 2153
{
};

/**
 * Convenience function, returns a reference to the global application stop controller instance
 **/

inline StopController& AppStopController() { return *(AppStopControllerSingleton::instance()); }

_ACS_END_NAMESPACE

#endif //_StopController_H_

